<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Casio WMP-1 Manager</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .connection-section {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            border: 2px dashed #ddd;
            border-radius: 8px;
        }
        
        .connection-section.connected {
            border-color: #4CAF50;
            background-color: #f8fff8;
        }
        
        .connection-section.error {
            border-color: #f44336;
            background-color: #fff8f8;
        }
        
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        
        .connect-btn {
            background-color: #28a745;
            font-size: 18px;
            padding: 12px 24px;
        }
        
        .connect-btn:hover {
            background-color: #218838;
        }
        
        .error-message {
            color: #d32f2f;
            background-color: #ffebee;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: none;
        }
        
        .success-message {
            color: #2e7d32;
            background-color: #e8f5e8;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            display: none;
        }
        
        .file-section {
            margin-top: 30px;
            display: none;
        }
        
        .file-section.visible {
            display: block;
        }
        
        .file-controls {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }
        
        .file-list {
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 200px;
            padding: 10px;
            background-color: white;
        }
        
        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid #eee;
            transition: background-color 0.2s ease;
            border-radius: 4px;
            margin-bottom: 2px;
        }
        
        .file-item:hover {
            background-color: #f8f9fa;
        }
        
        .file-item:last-child {
            border-bottom: none;
        }
        
        .file-item.empty-state {
            text-align: center;
            padding: 40px;
            background-color: #f8f9fa;
            border: 2px dashed #dee2e6;
            border-radius: 8px;
        }
        
        .file-info {
            flex-grow: 1;
            min-width: 0; /* Allow text truncation */
        }
        
        .file-name {
            font-weight: bold;
            margin-bottom: 6px;
            font-size: 16px;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-details {
            font-size: 12px;
            color: #666;
            line-height: 1.4;
        }
        
        .track-metadata {
            margin-bottom: 4px;
        }
        
        .track-metadata span {
            margin-right: 12px;
            display: inline-block;
        }
        
        .track-technical span {
            margin-right: 12px;
            display: inline-block;
        }
        
        .file-actions {
            margin-left: 15px;
        }
        
        .delete-btn {
            background-color: #dc3545;
            font-size: 13px;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.2s ease;
            border: none;
            color: white;
            cursor: pointer;
        }
        
        .delete-btn:hover {
            background-color: #c82333;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .delete-btn:active {
            transform: translateY(0);
        }
        
        .delete-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .space-info {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9ecef;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #e0e0e0;
            border-radius: 3px;
            margin-top: 5px;
        }
        
        .progress-fill {
            height: 100%;
            background-color: #007bff;
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        input[type="file"] {
            margin: 10px 0;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* File upload styles */
        .upload-area {
            border: 2px dashed #ddd;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 10px 0;
            background-color: #fafafa;
            transition: all 0.3s ease;
        }
        
        .upload-area.dragover {
            border-color: #007bff;
            background-color: #f0f8ff;
        }
        
        .upload-area:hover {
            border-color: #007bff;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        .file-input-wrapper input[type="file"] {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        
        .file-input-label {
            display: inline-block;
            padding: 10px 20px;
            background-color: #007bff;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        
        .file-input-label:hover {
            background-color: #0056b3;
        }
        
        .upload-progress {
            margin-top: 15px;
            display: none;
        }
        
        .upload-progress.visible {
            display: block;
        }
        
        .upload-file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin: 5px 0;
            background-color: #f8f9fa;
            border-radius: 4px;
            border-left: 4px solid #007bff;
        }
        
        .upload-file-info {
            flex-grow: 1;
        }
        
        .upload-file-name {
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .upload-file-details {
            font-size: 12px;
            color: #666;
        }
        
        .upload-file-progress {
            width: 100px;
            height: 4px;
            background-color: #e0e0e0;
            border-radius: 2px;
            margin: 5px 0;
        }
        
        .upload-file-progress-fill {
            height: 100%;
            background-color: #28a745;
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        .upload-status {
            font-size: 12px;
            font-weight: bold;
        }
        
        .upload-status.success {
            color: #28a745;
        }
        
        .upload-status.error {
            color: #dc3545;
        }
        
        .upload-status.uploading {
            color: #007bff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Casio WMP-1 Manager</h1>
        
        <div class="connection-section" id="connectionSection">
            <h3>Connect Your Watch</h3>
            <p>Click the button below to connect your Casio WMP-1 watch via USB.</p>
            <button class="connect-btn" id="connectBtn" onclick="connectToWatch()">
                Connect to Watch
            </button>
            <div class="error-message" id="errorMessage"></div>
            <div class="success-message" id="successMessage"></div>
        </div>
        
        <div class="file-section" id="fileSection">
            <div class="file-controls">
                <h3>File Management</h3>
                
                <div class="upload-area" id="uploadArea">
                    <div class="file-input-wrapper">
                        <input type="file" id="fileInput" accept=".mp3" multiple>
                        <label for="fileInput" class="file-input-label">Choose MP3 Files</label>
                    </div>
                    <p style="margin: 10px 0 5px 0; font-size: 14px; color: #666;">
                        Or drag and drop MP3 files here
                    </p>
                    <p style="margin: 0; font-size: 12px; color: #999;">
                        Supports 96-128kbps, 44.1kHz MP3 files
                    </p>
                </div>
                
                <div class="upload-progress" id="uploadProgress">
                    <h4>Upload Progress</h4>
                    <div id="uploadFileList"></div>
                </div>
                
                <div style="margin: 15px 0;">
                    <button onclick="uploadSelectedFiles()" id="uploadBtn" disabled>Upload Selected Files</button>
                    <button onclick="refreshFileList()" id="refreshBtn">Refresh File List</button>
                    <button onclick="testUSBFromUI()" id="testUSBBtn">Test MMC & TOC Operations</button>
                    <button onclick="testSpaceManagement()" id="testSpaceBtn">Test Space Management</button>
                    <button onclick="runProtocolCompatibilityTests()" id="protocolTestBtn">Run Protocol Compatibility Tests</button>
                </div>
            </div>
            
            <div class="file-list" id="fileList">
                <p>Loading files...</p>
            </div>
            
            <div class="space-info" id="spaceInfo">
                <div>Storage: <span id="usedSpace">0</span> / <span id="totalSpace">32</span> MB</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill" style="width: 0%"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Device constants matching the original C++ code
        const CASIO_VENDOR_ID = 0x07CF;
        const CASIO_PRODUCT_ID = 0x3801;
        const TOTAL_MMC_SIZE = 32047104; // 32MB MMC size
        
        // USB endpoint constants - based on original C++ code
        // C++ uses: bulk read from endpoint 130 (0x82), bulk write to endpoint 1 (0x01)
        // In WebUSB: endpoint 0x82 maps to endpoint 2, endpoint 0x01 maps to endpoint 1
        let USB_BULK_READ_ENDPOINT = 2;   // WebUSB endpoint 2 (from USB 0x82)
        let USB_BULK_WRITE_ENDPOINT = 1;  // WebUSB endpoint 1 (from USB 0x01)
        
        // Global state
        let device = null;
        let connected = false;
        let deviceState = {
            connected: false,
            device: null,
            totalSize: TOTAL_MMC_SIZE,
            trackCount: 0,
            tracks: [],
            usedSpace: new Map(),  // Map<offset, size> - tracks used space blocks
            freeSpace: 0,          // Total free space in bytes
            biggestFreeBlock: 0    // Size of largest contiguous free block
        };

        /**
         * USB Communication Layer - JavaScript port of usb_layer.cpp functions
         * 
         * This class provides the same USB communication interface as the original C++ code,
         * translating libusb calls to WebUSB API calls while maintaining protocol compatibility.
         * 
         * Key differences from C++ version:
         * - Uses WebUSB API instead of libusb
         * - Returns DataView objects instead of filling C-style buffers
         * - Uses async/await instead of synchronous calls
         * - Includes timeout management for all operations
         */
        class CasioUSB {
            constructor(device) {
                this.device = device;
            }

            /**
             * Helper function to add timeout to USB operations
             */
            async withTimeout(promise, timeout, operation) {
                return Promise.race([
                    promise,
                    new Promise((_, reject) => 
                        setTimeout(() => reject(new Error(`${operation} timed out after ${timeout}ms`)), timeout)
                    )
                ]);
            }

            /**
             * Clear halt condition on control endpoint
             * Note: WebUSB doesn't support clearHalt on control endpoint (endpoint 0)
             * Control endpoint stalls are automatically cleared by the next setup packet
             */
            async clearControlHalt() {
                // Control endpoint stalls are automatically cleared by the next control transfer
                // No action needed for WebUSB - just log for debugging
                console.log('Control endpoint stall will be cleared automatically by next transfer');
            }

            /**
             * Port of usb_vendor_message_out() function
             * Sends a vendor-specific control message to the device
             */
            async vendorMessageOut(recipient, requestNo, requestValue, buffer, timeout = 5000) {
                let retryCount = 0;
                const maxRetries = 2;
                
                while (retryCount <= maxRetries) {
                    try {
                        // Mask recipient to 5 bits as in C++ code
                        recipient &= 0x1F;
                        
                        // Convert buffer to Uint8Array if needed
                        if (!(buffer instanceof Uint8Array)) {
                            buffer = new Uint8Array(buffer);
                        }
                        
                        const transferPromise = this.device.controlTransferOut({
                            requestType: 'vendor',
                            recipient: recipient === 1 ? 'interface' : 'device',
                            request: requestNo,
                            value: requestValue,
                            index: 0
                        }, buffer);
                        
                        const result = await this.withTimeout(transferPromise, timeout, 'vendorMessageOut');
                        
                        if (result.status !== 'ok') {
                            throw new Error(`Vendor message out failed: ${result.status}`);
                        }
                        
                        return result.bytesWritten || 0;
                        
                    } catch (error) {
                        if (error.message.includes('stall') && retryCount < maxRetries) {
                            console.warn(`USB stall detected, attempting recovery (attempt ${retryCount + 1}/${maxRetries + 1})`);
                            await this.clearControlHalt();
                            // Longer delay for stall recovery
                            await new Promise(resolve => setTimeout(resolve, 250));
                            retryCount++;
                            continue;
                        }
                        
                        console.error('vendorMessageOut() error:', error);
                        console.error('Parameters:', { recipient, requestNo, requestValue, bufferLength: buffer?.length });
                        throw error;
                    }
                }
            }

            /**
             * Port of usb_vendor_message_in() function  
             * Receives a vendor-specific control message from the device
             */
            async vendorMessageIn(recipient, requestNo, requestValue, bufferLength, timeout = 5000) {
                let retryCount = 0;
                const maxRetries = 2;
                
                while (retryCount <= maxRetries) {
                    try {
                        // Mask recipient to 5 bits as in C++ code
                        recipient &= 0x1F;
                        
                        const transferPromise = this.device.controlTransferIn({
                            requestType: 'vendor',
                            recipient: recipient === 1 ? 'interface' : 'device',
                            request: requestNo,
                            value: requestValue,
                            index: 0
                        }, bufferLength);
                        
                        const result = await this.withTimeout(transferPromise, timeout, 'vendorMessageIn');
                        
                        if (result.status !== 'ok') {
                            throw new Error(`Vendor message in failed: ${result.status}`);
                        }
                        
                        return result.data;
                        
                    } catch (error) {
                        if (error.message.includes('stall') && retryCount < maxRetries) {
                            console.warn(`USB stall detected on vendor message in, attempting recovery (attempt ${retryCount + 1}/${maxRetries + 1})`);
                            await this.clearControlHalt();
                            // Longer delay for stall recovery
                            await new Promise(resolve => setTimeout(resolve, 250));
                            retryCount++;
                            continue;
                        }
                        
                        console.error('vendorMessageIn() error:', error);
                        console.error('Parameters:', { recipient, requestNo, requestValue, bufferLength });
                        throw error;
                    }
                }
            }

            /**
             * Port of usb_bulk_read() function
             * Reads data from a bulk endpoint
             * Note: C++ code uses endpoint 130 (0x82) for bulk reads, but WebUSB uses different numbering
             */
            async bulkRead(interfaceNumber, endpoint, length, timeout = 5000) {
                let retryCount = 0;
                const maxRetries = 2;
                
                while (retryCount <= maxRetries) {
                    try {
                        console.log(`bulkRead: endpoint=${endpoint}, length=${length}`);
                        
                        const transferPromise = this.device.transferIn(endpoint, length);
                        const result = await this.withTimeout(transferPromise, timeout, 'bulkRead');
                        
                        if (result.status !== 'ok') {
                            throw new Error(`Bulk read failed: ${result.status}`);
                        }
                        
                        console.log(`bulkRead: successfully read ${result.data.byteLength} bytes`);
                        return result.data;
                        
                    } catch (error) {
                        if (error.message.includes('stall') && retryCount < maxRetries) {
                            console.warn(`USB bulk read stall detected on endpoint ${endpoint}, attempting recovery (attempt ${retryCount + 1}/${maxRetries + 1})`);
                            await this.clearBulkHalt(endpoint);
                            await new Promise(resolve => setTimeout(resolve, 250)); // Longer delay for stall recovery
                            retryCount++;
                            continue;
                        }
                        
                        console.error('bulkRead() error:', error);
                        console.error('Parameters:', { interfaceNumber, endpoint, length });
                        console.error('Available endpoints:', { USB_BULK_READ_ENDPOINT, USB_BULK_WRITE_ENDPOINT });
                        throw error;
                    }
                }
            }

            /**
             * Clear halt condition on bulk endpoint
             */
            async clearBulkHalt(endpoint) {
                try {
                    // Determine direction based on endpoint number
                    // IN endpoints have bit 7 set (0x80), OUT endpoints don't
                    const direction = (endpoint & 0x80) ? 'in' : 'out';
                    await this.device.clearHalt(direction, endpoint);
                    console.log(`Cleared halt on bulk endpoint ${endpoint} (${direction})`);
                } catch (error) {
                    console.warn(`Failed to clear bulk halt on endpoint ${endpoint}:`, error.message);
                }
            }

            /**
             * Port of usb_bulk_write() function
             * Writes data to a bulk endpoint
             * Note: C++ code uses endpoint 1 (0x01) for bulk writes, but WebUSB uses different numbering
             */
            async bulkWrite(interfaceNumber, endpoint, buffer, timeout = 5000) {
                let retryCount = 0;
                const maxRetries = 2;
                
                while (retryCount <= maxRetries) {
                    try {
                        console.log(`bulkWrite: endpoint=${endpoint}, length=${buffer?.length}`);
                        
                        // Convert buffer to Uint8Array if needed
                        if (!(buffer instanceof Uint8Array)) {
                            buffer = new Uint8Array(buffer);
                        }
                        
                        const transferPromise = this.device.transferOut(endpoint, buffer);
                        const result = await this.withTimeout(transferPromise, timeout, 'bulkWrite');
                        
                        if (result.status !== 'ok') {
                            throw new Error(`Bulk write failed: ${result.status}`);
                        }
                        
                        console.log(`bulkWrite: successfully wrote ${result.bytesWritten || 0} bytes`);
                        return result.bytesWritten || 0;
                        
                    } catch (error) {
                        if (error.message.includes('stall') && retryCount < maxRetries) {
                            console.warn(`USB bulk stall detected on endpoint ${endpoint}, attempting recovery (attempt ${retryCount + 1}/${maxRetries + 1})`);
                            await this.clearBulkHalt(endpoint);
                            await new Promise(resolve => setTimeout(resolve, 250)); // Longer delay for stall recovery
                            retryCount++;
                            continue;
                        }
                        
                        console.error('bulkWrite() error:', error);
                        console.error('Parameters:', { interfaceNumber, endpoint, bufferLength: buffer?.length });
                        console.error('Available endpoints:', { USB_BULK_READ_ENDPOINT, USB_BULK_WRITE_ENDPOINT });
                        throw error;
                    }
                }
            }

            /**
             * Helper function to create properly sized buffers
             */
            createBuffer(size, data = null) {
                const buffer = new Uint8Array(size);
                if (data) {
                    if (Array.isArray(data)) {
                        buffer.set(data);
                    } else if (data instanceof Uint8Array) {
                        buffer.set(data);
                    }
                }
                return buffer;
            }

            /**
             * Helper function to convert DataView to Uint8Array
             */
            dataViewToUint8Array(dataView) {
                return new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength);
            }

            /**
             * Helper function to create little-endian 32-bit integer buffer
             * Used for MMC operations that need 32-bit values
             */
            createUint32LEBuffer(value) {
                const buffer = new ArrayBuffer(4);
                const view = new DataView(buffer);
                view.setUint32(0, value, true); // true = little endian
                return new Uint8Array(buffer);
            }

            /**
             * Helper function to read little-endian 32-bit integer from buffer
             */
            readUint32LE(buffer, offset = 0) {
                const view = new DataView(buffer.buffer || buffer, offset, 4);
                return view.getUint32(0, true); // true = little endian
            }

            /**
             * Helper function for debugging - converts buffer to hex string
             */
            bufferToHex(buffer) {
                return Array.from(new Uint8Array(buffer))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(' ');
            }
        }

        /**
         * MMC Manager - JavaScript port of MMC operations from casio_wmp.cpp
         * 
         * This class provides the same MMC read/write interface as the original C++ code,
         * handling 512-byte alignment requirements and device initialization sequences.
         * 
         * Key functions ported:
         * - MMC_Read() - Read data from MMC with 512-byte alignment
         * - MMC_Write() - Write data to MMC with proper padding
         * - Device initialization sequence from init_device()
         * - Status checking and device settling logic
         */
        class MMCManager {
            constructor(casioUSB) {
                this.casioUSB = casioUSB;
                this.mmcTotalSize = 0;
                this.mmcId = "";
                this.isInitialized = false;
            }

            /**
             * Port of MMC_Read() function from C++ code
             * Reads data from MMC with 512-byte alignment handling
             * 
             * @param {number} offset - Offset to read from
             * @param {number} length - Number of bytes to read
             * @returns {Promise<Uint8Array>} - Read data
             */
            async read(offset, length) {
                try {
                    console.log(`MMC_Read: offset=${offset}, length=${length}`);
                    
                    // Calculate transfer length with 512-byte alignment (same as C++ code)
                    const tempNum = length & 511;
                    const transferLength = tempNum !== 0 ? length + (512 - tempNum) : length;
                    
                    console.log(`MMC_Read: transferLength=${transferLength} (aligned from ${length})`);
                    
                    // Create setup buffer matching C++ code structure
                    const getSetup = new Uint8Array(16);
                    getSetup.fill(0);
                    
                    // Copy offset to bytes 4-7 (little endian)
                    const offsetView = new DataView(getSetup.buffer, 4, 4);
                    offsetView.setUint32(0, offset, true);
                    
                    // Copy end offset to bytes 8-11 (little endian)
                    const endOffset = offset + transferLength;
                    const endOffsetView = new DataView(getSetup.buffer, 8, 4);
                    endOffsetView.setUint32(0, endOffset, true);
                    
                    // Copy transfer length to bytes 12-15 (little endian)
                    const lengthView = new DataView(getSetup.buffer, 12, 4);
                    lengthView.setUint32(0, transferLength, true);
                    
                    console.log('MMC_Read: setup buffer:', Array.from(getSetup).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    
                    // Send bulk read control message (vendor message out, request 1)
                    const ret = await this.casioUSB.vendorMessageOut(1, 1, 0, getSetup);
                    if (ret < 0) {
                        throw new Error("Can't send bulk read control message request");
                    }
                    
                    // Perform bulk read using the discovered endpoint
                    // C++ code uses endpoint 130 (0x82), which maps to WebUSB endpoint number
                    console.log(`Performing bulk read from endpoint ${USB_BULK_READ_ENDPOINT}, length=${transferLength}...`);
                    const data = await this.casioUSB.bulkRead(0, USB_BULK_READ_ENDPOINT, transferLength);
                    const dataBytes = this.casioUSB.dataViewToUint8Array(data);
                    
                    console.log(`MMC_Read: got ${dataBytes.length} bulk bytes`);
                    
                    // Return only the requested length (trim padding)
                    return dataBytes.slice(0, length);
                    
                } catch (error) {
                    console.error('MMC_Read error:', error);
                    throw new Error(`MMC Reading failed: ${error.message}`);
                }
            }

            /**
             * Port of MMC_Write() function from C++ code
             * Writes data to MMC with proper 512-byte padding
             * 
             * @param {number} offset - Offset to write to
             * @param {Uint8Array} dataBuffer - Data to write
             * @returns {Promise<number>} - 0 on success, -1 on error
             */
            async write(offset, dataBuffer) {
                try {
                    let length = dataBuffer.length;
                    console.log(`MMC_Write: offset=${offset}, length=${length}`);
                    
                    // Calculate padding needed for 512-byte alignment
                    const tempNum = length & 511;
                    const padding = tempNum ? 512 - tempNum : 0;
                    
                    // Create padded data buffer
                    const paddedData = new Uint8Array(length + padding);
                    paddedData.set(dataBuffer, 0);
                    // Padding bytes are already 0 (Uint8Array is zero-initialized)
                    
                    length += padding;
                    console.log(`MMC_Write: padded length=${length} (padding=${padding})`);
                    
                    // Get status from device (vendor message in, request 4)
                    console.log('MMC_Write: getting device status...');
                    const statusData = await this.casioUSB.vendorMessageIn(1, 4, 0, 4);
                    const statusBytes = this.casioUSB.dataViewToUint8Array(statusData);
                    console.log('MMC_Write: device status:', Array.from(statusBytes));
                    
                    // Create setup buffer matching C++ code structure
                    const putSetup = new Uint8Array(16);
                    putSetup.fill(0);
                    
                    // Copy offset to bytes 4-7 (little endian)
                    const offsetView = new DataView(putSetup.buffer, 4, 4);
                    offsetView.setUint32(0, offset, true);
                    
                    // Copy end offset to bytes 8-11 (little endian)
                    const endOffset = offset + length;
                    const endOffsetView = new DataView(putSetup.buffer, 8, 4);
                    endOffsetView.setUint32(0, endOffset, true);
                    
                    // Copy length to bytes 12-15 (little endian)
                    const lengthView = new DataView(putSetup.buffer, 12, 4);
                    lengthView.setUint32(0, length, true);
                    
                    console.log('MMC_Write: setup buffer:', Array.from(putSetup).map(b => b.toString(16).padStart(2, '0')).join(' '));
                    
                    // Send bulk write control message (vendor message out, request 0)
                    const ret = await this.casioUSB.vendorMessageOut(1, 0, 0, putSetup);
                    if (ret < 0) {
                        throw new Error("Can't write bulk write control message");
                    }
                    
                    // Perform bulk write - try different endpoints systematically
                    let writeResult;
                    const endpointsToTry = [USB_BULK_WRITE_ENDPOINT, 1, 2, 3, 4, 5];
                    let lastError;
                    
                    for (const endpoint of endpointsToTry) {
                        try {
                            console.log(`Trying bulk write to endpoint ${endpoint}...`);
                            writeResult = await this.casioUSB.bulkWrite(0, endpoint, paddedData);
                            console.log(`Bulk write successful with endpoint ${endpoint}`);
                            USB_BULK_WRITE_ENDPOINT = endpoint; // Update for future calls
                            break;
                        } catch (error) {
                            console.warn(`Bulk write failed with endpoint ${endpoint}:`, error.message);
                            lastError = error;
                        }
                    }
                    
                    if (writeResult === undefined) {
                        throw new Error(`All bulk write endpoints failed. Last error: ${lastError.message}`);
                    }
                    
                    if (writeResult < 0) {
                        throw new Error("Bulk write failed");
                    }
                    
                    console.log(`MMC_Write: successfully wrote ${writeResult} bytes`);
                    return 0;
                    
                } catch (error) {
                    console.error('MMC_Write error:', error);
                    throw new Error(`MMC Writing failed: ${error.message}`);
                }
            }

            /**
             * Port of device initialization sequence from init_device() function
             * Handles device setup, configuration, and settling logic
             * 
             * @returns {Promise<boolean>} - true if initialization successful
             */
            async initializeDevice() {
                try {
                    console.log('MMC: Starting device initialization...');
                    
                    // Step 1: Get initial device status (vendor message in, request 4)
                    console.log('MMC: Getting initial device status...');
                    const statusData = await this.casioUSB.vendorMessageIn(1, 4, 0, 4);
                    const status = this.casioUSB.dataViewToUint8Array(statusData);
                    console.log('MMC: Initial device status:', Array.from(status));
                    
                    // Step 2: Check if device needs configuration setup
                    if (status[1] === 0) {
                        console.log('MMC: Device needs configuration setup...');
                        
                        // Set configuration to 1 (this is handled by WebUSB during connection)
                        // In WebUSB, we already called selectConfiguration(1) during connection
                        console.log('MMC: Configuration already set during WebUSB connection');
                        
                        // Wait for device to be ready
                        console.log('MMC: Waiting for device to be ready...');
                        let retries = 20; // 5 second timeout (20 * 250ms)
                        while (retries > 0) {
                            await this.sleep(250);
                            const newStatusData = await this.casioUSB.vendorMessageIn(1, 4, 0, 4);
                            const newStatus = this.casioUSB.dataViewToUint8Array(newStatusData);
                            console.log('MMC: Status check:', Array.from(newStatus));
                            
                            if (newStatus[1] !== 0) {
                                status[0] = newStatus[0];
                                status[1] = newStatus[1];
                                status[2] = newStatus[2];
                                status[3] = newStatus[3];
                                break;
                            }
                            retries--;
                        }
                        
                        if (retries === 0) {
                            throw new Error('Device configuration timeout');
                        }
                    }
                    
                    // Step 3: Check if watch needs to connect to dongle
                    if (status[1] === 2) {
                        console.log('MMC: Watch needs to connect to dongle...');
                        
                        // Send connect command (vendor message in, request 11)
                        const connectData = await this.casioUSB.vendorMessageIn(1, 11, 0, 1);
                        const connectStatus = this.casioUSB.dataViewToUint8Array(connectData);
                        
                        if (connectStatus[0] !== 1) {
                            throw new Error('Connecting to watch failed');
                        }
                        console.log('MMC: Watch connection initiated');
                        
                        // Wait for watch to settle
                        console.log('MMC: Waiting for watch to settle...');
                        let settleTimeout = 20; // 5 second timeout
                        let settled = false;
                        
                        while (settleTimeout > 0) {
                            await this.sleep(250);
                            console.log('MMC: Checking settle status...');
                            
                            const settleData = await this.casioUSB.vendorMessageIn(1, 4, 0, 4);
                            const settleStatus = this.casioUSB.dataViewToUint8Array(settleData);
                            console.log('MMC: Settle status:', Array.from(settleStatus));
                            
                            // Check for settled state: [3, 3, 0, 0]
                            if (settleStatus[0] === 3 && settleStatus[1] === 3 && 
                                settleStatus[2] === 0 && settleStatus[3] === 0) {
                                settled = true;
                                break;
                            }
                            
                            settleTimeout--;
                        }
                        
                        if (!settled) {
                            throw new Error('Watch does not settle - unable to connect');
                        }
                        console.log('MMC: Watch settled successfully');
                    }
                    
                    // Step 4: Read MMC ID to determine size
                    console.log('MMC: Reading MMC ID...');
                    try {
                        const mmcIdData = await this.casioUSB.vendorMessageIn(1, 9, 0, 16);
                        const mmcIdBytes = this.casioUSB.dataViewToUint8Array(mmcIdData);
                        this.mmcId = String.fromCharCode(...mmcIdBytes);
                        console.log('MMC: MMC ID:', this.casioUSB.bufferToHex(mmcIdBytes));
                        console.log('MMC: MMC ID string:', this.mmcId);
                        
                        // Check for 32M MMC (bytes 3-5 should be "32M")
                        const sizeString = String.fromCharCode(mmcIdBytes[3], mmcIdBytes[4], mmcIdBytes[5]);
                        if (sizeString === "32M") {
                            this.mmcTotalSize = 32047104; // 32MB MMC size from C++ code
                            console.log('MMC: Detected 32MB MMC');
                        } else {
                            throw new Error(`Unknown MMC size: ${sizeString}`);
                        }
                        
                    } catch (error) {
                        console.error('MMC: Error reading MMC ID:', error);
                        throw new Error("Can't read MMC ID - is the cradle closed?");
                    }
                    
                    this.isInitialized = true;
                    console.log('MMC: Device initialization completed successfully');
                    return true;
                    
                } catch (error) {
                    console.error('MMC: Device initialization failed:', error);
                    this.isInitialized = false;
                    throw error;
                }
            }

            /**
             * Port of TOC_ReadFromWatch() function
             * Reads the Table of Contents from the watch
             * 
             * @returns {Promise<Uint8Array>} - TOC data (16896 bytes)
             */
            async readTOC() {
                if (!this.isInitialized) {
                    throw new Error('MMC not initialized');
                }
                
                console.log('MMC: Reading TOC from watch...');
                const tocData = await this.read(0, 16896);
                console.log(`MMC: Read ${tocData.length} bytes of TOC data`);
                return tocData;
            }

            /**
             * Port of TOC_WriteToWatch() function
             * Writes the Table of Contents to the watch
             * 
             * @param {Uint8Array} tocData - TOC data to write (16896 bytes)
             * @returns {Promise<void>}
             */
            async writeTOC(tocData) {
                if (!this.isInitialized) {
                    throw new Error('MMC not initialized');
                }
                
                if (tocData.length !== 16896) {
                    throw new Error(`Invalid TOC size: ${tocData.length}, expected 16896`);
                }
                
                console.log('MMC: Writing TOC to watch...');
                await this.write(0, tocData);
                console.log('MMC: TOC write completed');
            }

            /**
             * Helper function for sleep/delay
             */
            sleep(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            /**
             * Get MMC total size
             */
            getTotalSize() {
                return this.mmcTotalSize;
            }

            /**
             * Get MMC ID string
             */
            getMMCId() {
                return this.mmcId;
            }

            /**
             * Check if MMC is initialized
             */
            isReady() {
                return this.isInitialized;
            }
        }

        /**
         * Space Management System - JavaScript port of space allocation functions from casio_wmp.cpp
         * 
         * This class provides file space management functionality including:
         * - Space allocation logic (port of TOC_FindSpace)
         * - Space tracking with used/free block management
         * - Space calculation functions for UI display
         * - File deletion with space reclamation
         * 
         * Key functions ported:
         * - TOC_FindSpace() - Find best-fit space for new files
         * - TOC_CalcFreeSpace() - Calculate total and biggest free blocks
         * - TOC_UseSpace() - Mark space as used with 512-byte alignment
         * - TOC_FreeSpace() - Reclaim space when files are deleted
         */
        class SpaceManager {
            constructor() {
                // Constants from C++ code
                this.TOC_SIZE = 16896;           // TOC takes first 16896 bytes
                this.BLOCK_ALIGNMENT = 512;      // All blocks must be 512-byte aligned
                
                // Space tracking - matches C++ MMC_UsedSpace map<int, int>
                this.usedSpace = new Map();      // Map<offset, size> - tracks used space blocks
                this.totalFree = 0;              // Total free space in bytes
                this.biggestFreeBlock = 0;       // Size of largest contiguous free block
                this.totalSize = TOTAL_MMC_SIZE; // Total MMC size
            }

            /**
             * Port of TOC_FindSpace() function from C++ code
             * Finds the best-fit space for a file of the requested size
             * 
             * @param {number} wish - Requested size in bytes
             * @returns {number} - Offset where file can be placed, or -1 if no space
             */
            findSpace(wish) {
                console.log(`SpaceManager.findSpace: looking for ${wish} bytes`);
                
                let start = this.TOC_SIZE;  // Start after TOC (16896 bytes)
                let bestFitOffset = -1;
                let bestFit = 0;

                // Sort used space by offset to iterate in order
                const sortedUsedSpace = Array.from(this.usedSpace.entries()).sort((a, b) => a[0] - b[0]);

                // Check gaps between used blocks
                for (const [offset, size] of sortedUsedSpace) {
                    const before = offset - start;
                    
                    if (before >= wish && (before < bestFit || bestFitOffset === -1)) {
                        bestFit = before;
                        bestFitOffset = start;
                    }
                    
                    start = offset + size;
                }

                // Check space after the last used block
                const after = this.totalSize - start;
                if (after >= wish && (after < bestFit || bestFitOffset === -1)) {
                    bestFit = after;
                    bestFitOffset = start;
                }

                console.log(`SpaceManager.findSpace: ${bestFitOffset === -1 ? 'no space found' : `found ${bestFit} bytes at offset ${bestFitOffset}`}`);
                return bestFitOffset;
            }

            /**
             * Port of TOC_CalcFreeSpace() function from C++ code
             * Calculates total free space and biggest free block
             */
            calcFreeSpace() {
                console.log('SpaceManager.calcFreeSpace: calculating free space...');
                
                let start = this.TOC_SIZE;  // Start after TOC
                this.biggestFreeBlock = 0;
                this.totalFree = 0;

                // Sort used space by offset to iterate in order
                const sortedUsedSpace = Array.from(this.usedSpace.entries()).sort((a, b) => a[0] - b[0]);

                // Calculate gaps between used blocks
                for (const [offset, size] of sortedUsedSpace) {
                    const before = offset - start;
                    
                    if (before < 0) {
                        console.warn(`SpaceManager.calcFreeSpace: negative space at offset ${offset}`);
                    }
                    
                    if (before > this.biggestFreeBlock) {
                        this.biggestFreeBlock = before;
                    }
                    
                    this.totalFree += before;
                    start = offset + size;
                }

                // Check space after the last used block
                const after = this.totalSize - start;
                if (after > this.biggestFreeBlock) {
                    this.biggestFreeBlock = after;
                }
                
                this.totalFree += after;

                console.log(`SpaceManager.calcFreeSpace: total free=${this.totalFree}, biggest block=${this.biggestFreeBlock}`);
            }

            /**
             * Port of TOC_UseSpace() function from C++ code
             * Marks space as used with 512-byte alignment
             * 
             * @param {number} itemOffset - Offset where space is used
             * @param {number} itemLength - Length of space to mark as used
             */
            useSpace(itemOffset, itemLength) {
                console.log(`SpaceManager.useSpace: marking ${itemLength} bytes at offset ${itemOffset}`);
                
                // Apply 512-byte alignment as in C++ code
                const tempNum = itemLength & 511;
                if (tempNum !== 0) {
                    itemLength += (512 - tempNum);
                }

                this.usedSpace.set(itemOffset, itemLength);
                console.log(`SpaceManager.useSpace: marked ${itemLength} bytes (aligned) at offset ${itemOffset}`);
                
                // Recalculate free space
                this.calcFreeSpace();
            }

            /**
             * Port of TOC_FreeSpace() function from C++ code
             * Reclaims space when a file is deleted
             * 
             * @param {number} itemOffset - Offset of space to free
             * @returns {boolean} - true if space was freed, false if offset not found
             */
            freeSpace(itemOffset) {
                console.log(`SpaceManager.freeSpace: freeing space at offset ${itemOffset}`);
                
                if (this.usedSpace.has(itemOffset)) {
                    const size = this.usedSpace.get(itemOffset);
                    this.usedSpace.delete(itemOffset);
                    console.log(`SpaceManager.freeSpace: freed ${size} bytes at offset ${itemOffset}`);
                    
                    // Recalculate free space
                    this.calcFreeSpace();
                    return true;
                } else {
                    console.error(`SpaceManager.freeSpace: unknown offset ${itemOffset}`);
                    return false;
                }
            }

            /**
             * Get space usage statistics for UI display
             * 
             * @returns {Object} - Space usage information
             */
            getSpaceInfo() {
                this.calcFreeSpace();
                
                const usedSpace = this.totalSize - this.totalFree;
                const usagePercent = (usedSpace / this.totalSize) * 100;
                
                return {
                    totalSize: this.totalSize,
                    usedSpace: usedSpace,
                    freeSpace: this.totalFree,
                    biggestFreeBlock: this.biggestFreeBlock,
                    usagePercent: usagePercent,
                    usedBlocks: this.usedSpace.size
                };
            }

            /**
             * Clear all used space (for initialization)
             */
            clearUsedSpace() {
                console.log('SpaceManager.clearUsedSpace: clearing all used space');
                this.usedSpace.clear();
                this.calcFreeSpace();
            }

            /**
             * Get a list of all used space blocks for debugging
             * 
             * @returns {Array} - Array of {offset, size} objects
             */
            getUsedSpaceBlocks() {
                return Array.from(this.usedSpace.entries())
                    .map(([offset, size]) => ({ offset, size }))
                    .sort((a, b) => a.offset - b.offset);
            }

            /**
             * Validate space allocation integrity
             * Checks for overlapping blocks and other issues
             * 
             * @returns {Object} - Validation results
             */
            validateSpaceIntegrity() {
                const blocks = this.getUsedSpaceBlocks();
                const issues = [];

                // Check for overlapping blocks
                for (let i = 0; i < blocks.length - 1; i++) {
                    const current = blocks[i];
                    const next = blocks[i + 1];
                    
                    if (current.offset + current.size > next.offset) {
                        issues.push(`Overlapping blocks: ${current.offset}-${current.offset + current.size} and ${next.offset}-${next.offset + next.size}`);
                    }
                }

                // Check for blocks before TOC
                for (const block of blocks) {
                    if (block.offset < this.TOC_SIZE) {
                        issues.push(`Block starts before TOC end: offset ${block.offset} < ${this.TOC_SIZE}`);
                    }
                }

                // Check for blocks beyond MMC size
                for (const block of blocks) {
                    if (block.offset + block.size > this.totalSize) {
                        issues.push(`Block extends beyond MMC: ${block.offset + block.size} > ${this.totalSize}`);
                    }
                }

                return {
                    valid: issues.length === 0,
                    issues: issues,
                    totalBlocks: blocks.length
                };
            }
        }

        /**
         * TOC Manager - JavaScript port of TOC operations from casio_wmp.cpp
         * 
         * This class provides the same TOC management interface as the original C++ code,
         * handling the 16896-byte table of contents structure and track metadata.
         * 
         * Key functions ported:
         * - TOC_ReadFromWatch() - Read TOC from watch
         * - TOC_ParseIntoArray() - Parse TOC into JavaScript objects
         * - TOC_GenerateFromArray() - Generate TOC from track list
         * - TOC_WriteToWatch() - Write TOC back to watch
         * - Space management functions for file allocation
         */
        class TOCManager {
            constructor(mmcManager, spaceManager) {
                this.mmcManager = mmcManager;
                this.spaceManager = spaceManager;
                
                // TOC structure constants from C++ code
                this.TOC_SIZE = 16896;           // Total TOC size
                this.TOC_HEADER_SIZE = 512;      // Header size
                this.TRACK_ENTRY_SIZE = 128;     // Size of each track entry
                this.MAX_TRACKS = 64;            // Maximum number of tracks
                this.MAX_STRING_LENGTH = 31;     // Maximum length for title/artist/album
                
                // TOC data buffer
                this.tocBuffer = new Uint8Array(this.TOC_SIZE);
                
                // Track data arrays (matching C++ global variables)
                this.trackCount = 0;
                this.trackOffsets = [];
                this.trackSizes = [];
                this.trackTitles = [];
                this.trackArtists = [];
                this.trackAlbums = [];
            }

            /**
             * Port of TOC_ReadFromWatch() function
             * Reads the 16896-byte TOC from the watch
             * 
             * @returns {Promise<number>} - 0 on success, -1 on error
             */
            async readFromWatch() {
                try {
                    console.log('TOC: Reading TOC from watch...');
                    
                    // Read 16896 bytes from offset 0 (same as C++ code)
                    const tocData = await this.mmcManager.read(0, this.TOC_SIZE);
                    
                    // Copy to our TOC buffer
                    this.tocBuffer.set(tocData);
                    
                    console.log('TOC: Successfully read TOC from watch');
                    return 0;
                    
                } catch (error) {
                    console.error('TOC_ReadFromWatch error:', error);
                    return -1;
                }
            }

            /**
             * Port of TOC_WriteToWatch() function
             * Writes the 16896-byte TOC back to the watch
             * 
             * @returns {Promise<number>} - 0 on success, -1 on error
             */
            async writeToWatch() {
                try {
                    console.log('TOC: Writing TOC to watch...');
                    
                    // Write 16896 bytes to offset 0 (same as C++ code)
                    const result = await this.mmcManager.write(0, this.tocBuffer);
                    
                    if (result === 0) {
                        console.log('TOC: Successfully wrote TOC to watch');
                        return 0;
                    } else {
                        throw new Error('MMC write failed');
                    }
                    
                } catch (error) {
                    console.error('TOC_WriteToWatch error:', error);
                    return -1;
                }
            }

            /**
             * Port of TOC_ParseIntoArray() function
             * Parses the TOC buffer into JavaScript arrays
             * 
             * @returns {Promise<number>} - 0 on success, -1 on error
             */
            async parseIntoArray() {
                try {
                    console.log('TOC: Parsing TOC into arrays...');
                    
                    // Read track count from offset 4 (little endian, same as C++ code)
                    const trackCountView = new DataView(this.tocBuffer.buffer, 4, 4);
                    this.trackCount = trackCountView.getUint32(0, true); // true = little endian
                    
                    console.log(`TOC: Found ${this.trackCount} tracks`);
                    
                    // Initialize arrays
                    this.trackOffsets = new Array(this.trackCount);
                    this.trackSizes = new Array(this.trackCount);
                    this.trackTitles = new Array(this.trackCount);
                    this.trackArtists = new Array(this.trackCount);
                    this.trackAlbums = new Array(this.trackCount);
                    
                    // Clear used space map in SpaceManager
                    this.spaceManager.clearUsedSpace();
                    
                    // Parse each track entry (starting at offset 512, same as C++ code)
                    let curPos = this.TOC_HEADER_SIZE;
                    
                    for (let trackNo = 0; trackNo < this.trackCount; trackNo++) {
                        // Read track offset (4 bytes, little endian)
                        const offsetView = new DataView(this.tocBuffer.buffer, curPos, 4);
                        this.trackOffsets[trackNo] = offsetView.getUint32(0, true);
                        
                        // Read track size (4 bytes, little endian)
                        const sizeView = new DataView(this.tocBuffer.buffer, curPos + 4, 4);
                        this.trackSizes[trackNo] = sizeView.getUint32(0, true);
                        
                        // Read title (32 bytes, null-terminated string)
                        this.trackTitles[trackNo] = this.readNullTerminatedString(curPos + 8, 32);
                        
                        // Read artist (32 bytes, null-terminated string)
                        this.trackArtists[trackNo] = this.readNullTerminatedString(curPos + 40, 32);
                        
                        // Read album (32 bytes, null-terminated string)
                        this.trackAlbums[trackNo] = this.readNullTerminatedString(curPos + 72, 32);
                        
                        // Mark this space as used via SpaceManager (same as C++ TOC_UseSpace)
                        this.spaceManager.useSpace(this.trackOffsets[trackNo], this.trackSizes[trackNo]);
                        
                        // Move to next track entry
                        curPos += this.TRACK_ENTRY_SIZE;
                        
                        // Safety check (same as C++ code)
                        if (curPos > 8704) {
                            console.warn('TOC: Warning - beyond the end of the TOC!');
                            break;
                        }
                        
                        console.log(`TOC: Track ${trackNo + 1}: "${this.trackTitles[trackNo]}" by "${this.trackArtists[trackNo]}" (${this.trackSizes[trackNo]} bytes)`);
                    }
                    
                    console.log('TOC: Successfully parsed TOC into arrays');
                    return 0;
                    
                } catch (error) {
                    console.error('TOC_ParseIntoArray error:', error);
                    return -1;
                }
            }

            /**
             * Port of TOC_GenerateFromArray() function
             * Generates TOC buffer from JavaScript arrays
             * 
             * @returns {Promise<number>} - 0 on success, -1 on error
             */
            async generateFromArray() {
                try {
                    console.log('TOC: Generating TOC from arrays...');
                    
                    // Clear the TOC buffer
                    this.tocBuffer.fill(0);
                    
                    // Update counters in TOC header (same structure as C++ code)
                    // Bytes 0-3: zeros
                    const trackCountView1 = new DataView(this.tocBuffer.buffer, 4, 4);
                    trackCountView1.setUint32(0, this.trackCount, true); // little endian
                    
                    // Bytes 8-9: zeros
                    const trackCountView2 = new DataView(this.tocBuffer.buffer, 10, 4);
                    trackCountView2.setUint32(0, this.trackCount, true); // little endian
                    
                    // Bytes 14-15: zeros (already filled with zeros above)
                    
                    // Generate track entries
                    for (let i = 0; i < this.trackCount; i++) {
                        // Truncate strings to maximum length (same as C++ code)
                        let title = this.trackTitles[i] || '';
                        let artist = this.trackArtists[i] || '';
                        let album = this.trackAlbums[i] || '';
                        
                        if (title.length > this.MAX_STRING_LENGTH) {
                            title = title.substring(0, this.MAX_STRING_LENGTH);
                        }
                        if (artist.length > this.MAX_STRING_LENGTH) {
                            artist = artist.substring(0, this.MAX_STRING_LENGTH);
                        }
                        if (album.length > this.MAX_STRING_LENGTH) {
                            album = album.substring(0, this.MAX_STRING_LENGTH);
                        }
                        
                        // Calculate track entry position
                        const trackEntryPos = i * this.TRACK_ENTRY_SIZE + this.TOC_HEADER_SIZE;
                        
                        // Clear track entry
                        this.tocBuffer.fill(0, trackEntryPos, trackEntryPos + this.TRACK_ENTRY_SIZE);
                        
                        // Write track offset (4 bytes, little endian)
                        const offsetView = new DataView(this.tocBuffer.buffer, trackEntryPos, 4);
                        offsetView.setUint32(0, this.trackOffsets[i], true);
                        
                        // Write track size (4 bytes, little endian)
                        const sizeView = new DataView(this.tocBuffer.buffer, trackEntryPos + 4, 4);
                        sizeView.setUint32(0, this.trackSizes[i], true);
                        
                        // Write title (32 bytes max, null-terminated)
                        this.writeNullTerminatedString(trackEntryPos + 8, title, 32);
                        
                        // Write artist (32 bytes max, null-terminated)
                        this.writeNullTerminatedString(trackEntryPos + 40, artist, 32);
                        
                        // Write album (32 bytes max, null-terminated)
                        this.writeNullTerminatedString(trackEntryPos + 72, album, 32);
                        
                        console.log(`TOC: Generated entry ${i + 1}: "${title}" by "${artist}"`);
                    }
                    
                    console.log('TOC: Successfully generated TOC from arrays');
                    return 0;
                    
                } catch (error) {
                    console.error('TOC_GenerateFromArray error:', error);
                    return -1;
                }
            }

            /**
             * Port of TOC_UseSpace() function
             * Marks a space region as used via SpaceManager
             * 
             * @param {number} itemOffset - Offset of the item
             * @param {number} itemLength - Length of the item
             */
            useSpace(itemOffset, itemLength) {
                this.spaceManager.useSpace(itemOffset, itemLength);
            }

            /**
             * Port of TOC_FreeSpace() function
             * Marks a space region as free via SpaceManager
             * 
             * @param {number} itemOffset - Offset to free
             * @returns {boolean} - true if space was freed, false if offset not found
             */
            freeSpace(itemOffset) {
                return this.spaceManager.freeSpace(itemOffset);
            }

            /**
             * Port of TOC_FindSpace() function
             * Finds available space for a file of given size via SpaceManager
             * 
             * @param {number} wish - Desired size in bytes
             * @returns {number} - Offset where space is available, or -1 if not found
             */
            findSpace(wish) {
                return this.spaceManager.findSpace(wish);
            }

            /**
             * Port of TOC_CalcFreeSpace() function
             * Calculates total free space and biggest free block via SpaceManager
             */
            calcFreeSpace() {
                this.spaceManager.calcFreeSpace();
            }

            /**
             * Helper function to read null-terminated string from TOC buffer
             * 
             * @param {number} offset - Offset in TOC buffer
             * @param {number} maxLength - Maximum string length
             * @returns {string} - Extracted string
             */
            readNullTerminatedString(offset, maxLength) {
                const bytes = [];
                for (let i = 0; i < maxLength; i++) {
                    const byte = this.tocBuffer[offset + i];
                    if (byte === 0) break; // Null terminator
                    bytes.push(byte);
                }
                return String.fromCharCode(...bytes);
            }

            /**
             * Helper function to write null-terminated string to TOC buffer
             * 
             * @param {number} offset - Offset in TOC buffer
             * @param {string} str - String to write
             * @param {number} maxLength - Maximum field length
             */
            writeNullTerminatedString(offset, str, maxLength) {
                // Convert string to bytes
                const bytes = new TextEncoder().encode(str);
                
                // Copy bytes to buffer (up to maxLength - 1 to leave room for null terminator)
                const copyLength = Math.min(bytes.length, maxLength - 1);
                for (let i = 0; i < copyLength; i++) {
                    this.tocBuffer[offset + i] = bytes[i];
                }
                
                // Ensure null termination
                if (copyLength < maxLength) {
                    this.tocBuffer[offset + copyLength] = 0;
                }
            }

            /**
             * Get track information as objects for UI display
             * 
             * @returns {Array} - Array of track objects
             */
            getTrackList() {
                const tracks = [];
                for (let i = 0; i < this.trackCount; i++) {
                    tracks.push({
                        index: i,
                        offset: this.trackOffsets[i],
                        size: this.trackSizes[i],
                        title: this.trackTitles[i] || '',
                        artist: this.trackArtists[i] || '',
                        album: this.trackAlbums[i] || ''
                    });
                }
                return tracks;
            }

            /**
             * Add a new track to the TOC
             * 
             * @param {number} offset - File offset on MMC
             * @param {number} size - File size in bytes
             * @param {string} title - Track title
             * @param {string} artist - Track artist
             * @param {string} album - Track album
             */
            addTrack(offset, size, title, artist, album) {
                this.trackCount++;
                this.trackOffsets.push(offset);
                this.trackSizes.push(size);
                this.trackTitles.push(title || '');
                this.trackArtists.push(artist || '');
                this.trackAlbums.push(album || '');
                
                this.useSpace(offset, size);
                console.log(`TOC: Added track "${title}" by "${artist}" at offset ${offset}`);
            }

            /**
             * Remove a track from the TOC
             * 
             * @param {number} trackIndex - Index of track to remove (0-based)
             */
            removeTrack(trackIndex) {
                if (trackIndex < 0 || trackIndex >= this.trackCount) {
                    console.error(`TOC: Invalid track index ${trackIndex}`);
                    return;
                }
                
                // Free the space
                this.freeSpace(this.trackOffsets[trackIndex]);
                
                // Remove from arrays
                this.trackOffsets.splice(trackIndex, 1);
                this.trackSizes.splice(trackIndex, 1);
                this.trackTitles.splice(trackIndex, 1);
                this.trackArtists.splice(trackIndex, 1);
                this.trackAlbums.splice(trackIndex, 1);
                
                this.trackCount--;
                console.log(`TOC: Removed track at index ${trackIndex}`);
            }

            /**
             * Clear all tracks from the TOC
             */
            clearAllTracks() {
                // Free all used space
                for (const offset of this.trackOffsets) {
                    this.freeSpace(offset);
                }
                
                // Clear arrays
                this.trackCount = 0;
                this.trackOffsets = [];
                this.trackSizes = [];
                this.trackTitles = [];
                this.trackArtists = [];
                this.trackAlbums = [];
                
                console.log('TOC: Cleared all tracks');
            }
        }

        // Global USB communication instance
        let casioUSB = null;
        
        // Global MMC manager instance
        let mmcManager = null;
        
        // Global TOC manager instance
        let tocManager = null;
        
        // Global Space manager instance
        let spaceManager = null;

        /**
         * Discover the correct endpoint numbers from the device configuration
         * WebUSB uses different endpoint numbering than raw USB values
         */
        function discoverEndpoints(device) {
            console.log('Discovering USB endpoints...');
            console.log('Device configuration:', device.configuration);
            
            if (!device.configuration || !device.configuration.interfaces) {
                console.warn('No device configuration available, using default endpoints');
                return;
            }
            
            // Look through interfaces for bulk endpoints
            for (const iface of device.configuration.interfaces) {
                console.log(`Interface ${iface.interfaceNumber}:`);
                
                for (const alt of iface.alternates) {
                    console.log(`  Alternate ${alt.alternateSetting}:`);
                    console.log(`  Endpoints:`, alt.endpoints);
                    
                    for (const endpoint of alt.endpoints) {
                        console.log(`    Endpoint ${endpoint.endpointNumber} (0x${endpoint.endpointNumber.toString(16)}): ${endpoint.direction} ${endpoint.type} (packetSize: ${endpoint.packetSize})`);
                        
                        if (endpoint.type === 'bulk') {
                            if (endpoint.direction === 'in') {
                                // Convert USB endpoint number to WebUSB format
                                // USB endpoint 0x82 (130) -> WebUSB endpoint 2
                                // USB endpoint 0x81 (129) -> WebUSB endpoint 1, etc.
                                let webUSBEndpoint = endpoint.endpointNumber & 0x0F; // Remove direction bit
                                USB_BULK_READ_ENDPOINT = webUSBEndpoint;
                                console.log(`    -> Using endpoint ${webUSBEndpoint} for bulk read (USB: 0x${endpoint.endpointNumber.toString(16)})`);
                            } else if (endpoint.direction === 'out') {
                                // For OUT endpoints, the number is already correct
                                USB_BULK_WRITE_ENDPOINT = endpoint.endpointNumber;
                                console.log(`    -> Using endpoint ${endpoint.endpointNumber} for bulk write`);
                            }
                        }
                    }
                }
            }
            
            console.log(`Final endpoints: READ=${USB_BULK_READ_ENDPOINT}, WRITE=${USB_BULK_WRITE_ENDPOINT}`);
            
            // If no bulk endpoints found in configuration, stick with the C++ values
            // The original C++ code uses endpoint 130 (0x82) for read and 1 (0x01) for write
            // In WebUSB terms, this should be endpoint 2 for read and endpoint 1 for write
        }

        // Check WebUSB support on page load
        window.addEventListener('DOMContentLoaded', function() {
            checkWebUSBSupport();
            setupFileUploadUI();
        });

        /**
         * Setup file upload UI with drag-and-drop support
         */
        function setupFileUploadUI() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            // File input change handler
            fileInput.addEventListener('change', function() {
                const files = Array.from(this.files);
                
                if (files.length > 0) {
                    // Validate selected files
                    const validation = validateFiles(files);
                    
                    // Show validation results
                    if (validation.invalid.length > 0) {
                        const errorMessages = validation.invalid.map(item => 
                            `${item.file.name}: ${item.errors.join(', ')}`
                        ).join('\n');
                        showWarning(`Some files have issues:\n${errorMessages}`);
                    }
                    
                    if (validation.warnings.length > 0) {
                        showWarning(`File warnings: ${validation.warnings.join(', ')}`);
                    }
                    
                    // Log file info
                    console.log(`Selected ${files.length} file(s) (${validation.valid.length} valid):`);
                    files.forEach(file => {
                        console.log(`  - ${file.name} (${Math.round(file.size / 1024)} KB)`);
                    });
                    
                    // Show space check if connected
                    if (connected && spaceManager) {
                        const spaceInfo = spaceManager.getSpaceInfo();
                        const totalSizeMB = Math.round(validation.totalSize / 1024 / 1024 * 10) / 10;
                        const availableMB = Math.round(spaceInfo.freeSpace / 1024 / 1024 * 10) / 10;
                        
                        if (validation.totalSize > spaceInfo.freeSpace) {
                            showWarning(`Selected files (${totalSizeMB}MB) exceed available space (${availableMB}MB)`);
                        }
                    }
                }
                
                updateUploadButtonState();
            });
            
            // Drag and drop handlers
            uploadArea.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.add('dragover');
            });
            
            uploadArea.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.remove('dragover');
            });
            
            uploadArea.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                this.classList.remove('dragover');
                
                const files = Array.from(e.dataTransfer.files);
                
                // Validate all dropped files
                const validation = validateFiles(files);
                
                if (validation.valid.length === 0) {
                    if (validation.invalid.length > 0) {
                        const errorMessages = validation.invalid.map(item => 
                            `${item.file.name}: ${item.errors.join(', ')}`
                        ).join('\n');
                        showError(`Invalid files:\n${errorMessages}`, ErrorCategories.FILE_VALIDATION);
                    } else {
                        showError('Please drop MP3 files only', ErrorCategories.FILE_VALIDATION);
                    }
                    return;
                }
                
                // Show warnings for any issues
                if (validation.warnings.length > 0) {
                    showWarning(`File warnings: ${validation.warnings.join(', ')}`);
                }
                
                // Show info about filtered files
                if (validation.invalid.length > 0) {
                    showWarning(`${validation.valid.length} of ${files.length} files are valid MP3 files`);
                }
                
                // Create a new FileList-like object and assign to input
                const dt = new DataTransfer();
                validation.valid.forEach(file => dt.items.add(file));
                fileInput.files = dt.files;
                
                // Trigger change event
                fileInput.dispatchEvent(new Event('change'));
                
                console.log(`Dropped ${validation.valid.length} valid MP3 file(s)`);
            });
            
            // Prevent default drag behaviors on document
            document.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            
            document.addEventListener('drop', function(e) {
                e.preventDefault();
            });
        }

        function checkWebUSBSupport() {
            if (!navigator.usb) {
                showError('WebUSB is not supported in this browser. Please use Chrome or Edge with HTTPS.', ErrorCategories.BROWSER_SUPPORT);
                document.getElementById('connectBtn').disabled = true;
                return false;
            }
            
            if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                showError('WebUSB requires HTTPS. Please access this page over HTTPS.', ErrorCategories.BROWSER_SUPPORT);
                document.getElementById('connectBtn').disabled = true;
                return false;
            }
            
            return true;
        }

        async function connectToWatch() {
            if (!checkWebUSBSupport()) {
                return;
            }

            const connectBtn = document.getElementById('connectBtn');
            const originalText = connectBtn.textContent;
            
            try {
                connectBtn.disabled = true;
                connectBtn.innerHTML = 'Connecting... <span class="loading"></span>';
                hideMessages();

                // Request device access
                device = await navigator.usb.requestDevice({
                    filters: [{
                        vendorId: CASIO_VENDOR_ID,
                        productId: CASIO_PRODUCT_ID
                    }]
                });

                // Open the device
                await device.open();
                
                // Select configuration (usually configuration 1)
                if (device.configuration === null) {
                    await device.selectConfiguration(1);
                }

                // Claim the interface (usually interface 0)
                await device.claimInterface(0);

                // Discover correct endpoint numbers from device configuration
                discoverEndpoints(device);
                
                // Log full device information for debugging
                console.log('Device info:', {
                    vendorId: device.vendorId,
                    productId: device.productId,
                    deviceClass: device.deviceClass,
                    deviceSubclass: device.deviceSubclass,
                    deviceProtocol: device.deviceProtocol,
                    configuration: device.configuration
                });

                // Create USB communication instance
                casioUSB = new CasioUSB(device);

                // Create MMC manager instance
                mmcManager = new MMCManager(casioUSB);

                // Initialize MMC device (includes device setup and status checking)
                try {
                    console.log('Initializing MMC device...');
                    await mmcManager.initializeDevice();
                    console.log('MMC device initialized successfully');
                    console.log('MMC Total Size:', mmcManager.getTotalSize());
                    console.log('MMC ID:', mmcManager.getMMCId());
                } catch (error) {
                    console.error('MMC initialization failed:', error);
                    throw new Error(`MMC initialization failed: ${error.message}`);
                }

                // Create Space manager instance
                spaceManager = new SpaceManager();
                
                // Create TOC manager instance
                tocManager = new TOCManager(mmcManager, spaceManager);

                // Create File manager instance for testing
                fileManager = new FileManager(tocManager, mmcManager, spaceManager);

                // Read and parse TOC from watch
                try {
                    console.log('Reading TOC from watch...');
                    const readResult = await tocManager.readFromWatch();
                    if (readResult !== 0) {
                        throw new Error('Failed to read TOC from watch');
                    }

                    console.log('Parsing TOC into arrays...');
                    const parseResult = await tocManager.parseIntoArray();
                    if (parseResult !== 0) {
                        throw new Error('Failed to parse TOC');
                    }

                    // Calculate free space
                    tocManager.calcFreeSpace();
                    
                    console.log(`TOC loaded successfully: ${tocManager.trackCount} tracks found`);
                    console.log(`Free space: ${Math.round(tocManager.totalFree / 1024)} KB (${Math.round(tocManager.biggestFreeBlock / 1024)} KB largest block)`);
                    
                } catch (error) {
                    console.error('TOC initialization failed:', error);
                    throw new Error(`TOC initialization failed: ${error.message}`);
                }

                // Update connection state
                connected = true;
                deviceState.connected = true;
                deviceState.device = device;

                // Update UI
                updateConnectionUI(true);
                showSuccess('Successfully connected to Casio WMP-1!');
                
                // Show file management section
                document.getElementById('fileSection').classList.add('visible');
                
                // Update upload button state
                updateUploadButtonState();
                
                // Load initial file list
                await refreshFileList();

            } catch (error) {
                console.error('Connection failed:', error);
                connected = false;
                deviceState.connected = false;
                
                let category = ErrorCategories.CONNECTION;
                let errorMsg = error.message || 'Unknown error occurred';
                
                // Categorize and provide user-friendly messages
                if (error.name === 'NotFoundError') {
                    errorMsg = 'No Casio WMP-1 device found. Make sure your watch is connected and in the correct mode.';
                    category = ErrorCategories.CONNECTION;
                } else if (error.name === 'NotAllowedError') {
                    errorMsg = 'Permission denied. Please try again and allow access to the device.';
                    category = ErrorCategories.CONNECTION;
                } else if (error.name === 'NetworkError') {
                    errorMsg = 'Device communication error. Try disconnecting and reconnecting your watch.';
                    category = ErrorCategories.USB_COMMUNICATION;
                } else if (error.message.includes('timeout')) {
                    category = ErrorCategories.USB_COMMUNICATION;
                } else if (error.message.includes('MMC') || error.message.includes('TOC')) {
                    category = ErrorCategories.DEVICE_OPERATION;
                }
                
                showError(errorMsg, category, connectToWatch);
                updateConnectionUI(false);
            } finally {
                connectBtn.disabled = false;
                connectBtn.textContent = connected ? 'Disconnect' : originalText;
            }
        }

        function updateConnectionUI(isConnected) {
            const connectionSection = document.getElementById('connectionSection');
            const connectBtn = document.getElementById('connectBtn');
            
            if (isConnected) {
                connectionSection.classList.add('connected');
                connectionSection.classList.remove('error');
                connectBtn.textContent = 'Disconnect';
                connectBtn.onclick = disconnectFromWatch;
            } else {
                connectionSection.classList.remove('connected');
                connectBtn.textContent = 'Connect to Watch';
                connectBtn.onclick = connectToWatch;
                document.getElementById('fileSection').classList.remove('visible');
                
                // Update upload button state
                updateUploadButtonState();
            }
        }

        async function disconnectFromWatch() {
            try {
                if (device) {
                    await device.close();
                    device = null;
                }
                
                connected = false;
                deviceState.connected = false;
                deviceState.device = null;
                casioUSB = null;
                mmcManager = null;
                
                updateConnectionUI(false);
                showSuccess('Disconnected from watch.');
                hideMessages();
                
                // Update upload button state
                updateUploadButtonState();
                
            } catch (error) {
                console.error('Disconnect error:', error);
                showError('Error disconnecting from watch: ' + error.message, ErrorCategories.CONNECTION);
            }
        }

        // Throttling for refreshFileList to prevent rapid successive calls
        let refreshFileListThrottle = null;
        let lastRefreshTime = 0;
        const MIN_REFRESH_INTERVAL = 1000; // Minimum 1 second between refreshes

        async function refreshFileList(force = false) {
            if (!connected || !device || !tocManager || !mmcManager || !spaceManager) {
                console.warn('Cannot refresh file list - not connected or managers not initialized');
                return;
            }

            // Throttle rapid successive calls unless forced
            const now = Date.now();
            if (!force && (now - lastRefreshTime) < MIN_REFRESH_INTERVAL) {
                console.log('Throttling refreshFileList call - too soon after last refresh');
                
                // Clear existing throttle and set new one
                if (refreshFileListThrottle) {
                    clearTimeout(refreshFileListThrottle);
                }
                
                refreshFileListThrottle = setTimeout(() => {
                    refreshFileList(true); // Force the delayed call
                }, MIN_REFRESH_INTERVAL - (now - lastRefreshTime));
                
                return;
            }
            
            lastRefreshTime = now;

            const fileList = document.getElementById('fileList');
            const refreshBtn = document.getElementById('refreshBtn');
            
            try {
                console.log('Refreshing file list...');
                
                // Show loading state with spinner
                showLoadingState(fileList, 'Loading files from watch...');
                
                // Disable refresh button during loading
                if (refreshBtn) {
                    refreshBtn.disabled = true;
                    refreshBtn.innerHTML = '<span class="loading"></span> Refreshing...';
                }
                
                // Read and parse TOC with retry logic
                await retryOperation(async () => {
                    const readResult = await tocManager.readFromWatch();
                    if (readResult !== 0) {
                        throw new Error('Failed to read TOC from watch');
                    }
                    
                    // Small delay between read and parse to give device time to recover
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    const parseResult = await tocManager.parseIntoArray();
                    if (parseResult !== 0) {
                        throw new Error('Failed to parse TOC data');
                    }
                }, ErrorCategories.DEVICE_OPERATION, 'TOC read and parse');

                // Calculate free space
                tocManager.calcFreeSpace();
                
                // Get track list from TOC manager
                const tracks = tocManager.getTrackList();
                console.log(`Found ${tracks.length} tracks on watch`);
                
                // Display file list with enhanced information
                displayFileList(tracks);
                
                // Update space info with real-time data
                updateRealTimeSpaceInfo();
                
                console.log(`File list refreshed: ${tracks.length} tracks, ${Math.round(spaceManager.getSpaceInfo().freeSpace / 1024)} KB free`);
                
            } catch (error) {
                console.error('Error loading files:', error);
                
                let category = ErrorCategories.DEVICE_OPERATION;
                if (error.message.includes('timeout')) {
                    category = ErrorCategories.USB_COMMUNICATION;
                } else if (error.message.includes('TOC')) {
                    category = ErrorCategories.DEVICE_OPERATION;
                }
                
                showError('Failed to load file list: ' + error.message, category, refreshFileList);
                showErrorState(fileList, 'Error loading files from watch');
            } finally {
                // Re-enable refresh button
                if (refreshBtn) {
                    refreshBtn.disabled = false;
                    refreshBtn.innerHTML = 'Refresh File List';
                }
            }
        }

        /**
         * Display file list with enhanced track information and interactive elements
         * Implements requirement 1.3: Display current files on watch with detailed information
         */
        function displayFileList(tracks) {
            const fileList = document.getElementById('fileList');
            
            if (tracks.length === 0) {
                fileList.innerHTML = `
                    <div class="file-item empty-state">
                        <div class="file-info">
                            <div class="file-name">🎵 No files on watch</div>
                            <div class="file-details">The watch is empty. Upload some MP3 files to get started.</div>
                        </div>
                    </div>
                `;
                return;
            }

            // Sort tracks by title for better organization
            const sortedTracks = [...tracks].sort((a, b) => {
                const titleA = (a.title || `Track ${a.index + 1}`).toLowerCase();
                const titleB = (b.title || `Track ${b.index + 1}`).toLowerCase();
                return titleA.localeCompare(titleB);
            });

            let html = '';
            sortedTracks.forEach((track) => {
                const sizeKB = Math.round(track.size / 1024);
                const sizeMB = (track.size / (1024 * 1024)).toFixed(1);
                const displayTitle = track.title || `Track ${track.index + 1}`;
                const displayArtist = track.artist || 'Unknown Artist';
                const displayAlbum = track.album || '';
                
                // Calculate duration estimate (rough estimate: 1MB ≈ 1 minute for 128kbps MP3)
                const estimatedDuration = Math.round(track.size / (1024 * 1024));
                const durationText = estimatedDuration > 0 ? ` • ~${estimatedDuration}min` : '';
                
                html += `
                    <div class="file-item" data-track-index="${track.index}">
                        <div class="file-info">
                            <div class="file-name" title="${displayTitle}">
                                🎵 ${displayTitle}
                            </div>
                            <div class="file-details">
                                <div class="track-metadata">
                                    <span class="artist" title="Artist: ${displayArtist}">👤 ${displayArtist}</span>
                                    ${displayAlbum ? `<span class="album" title="Album: ${displayAlbum}">💿 ${displayAlbum}</span>` : ''}
                                </div>
                                <div class="track-technical">
                                    <span class="size" title="File size">📁 ${sizeKB} KB (${sizeMB} MB)</span>
                                    <span class="offset" title="Storage offset">📍 Offset: ${track.offset.toLocaleString()}</span>
                                    ${durationText}
                                </div>
                            </div>
                        </div>
                        <div class="file-actions">
                            <button class="delete-btn" onclick="deleteFile(${track.index})" 
                                    title="Delete this track from watch">
                                🗑️ Delete
                            </button>
                        </div>
                    </div>
                `;
            });
            
            fileList.innerHTML = html;
            
            // Add file count summary
            const summaryElement = document.createElement('div');
            summaryElement.className = 'file-list-summary';
            summaryElement.innerHTML = `
                <div style="text-align: center; padding: 10px; background-color: #f8f9fa; border-radius: 4px; margin-top: 10px; font-size: 14px; color: #666;">
                    📊 Total: ${tracks.length} track${tracks.length !== 1 ? 's' : ''} • 
                    ${Math.round(tracks.reduce((sum, t) => sum + t.size, 0) / 1024)} KB used
                </div>
            `;
            fileList.appendChild(summaryElement);
        }

        /**
         * Show loading state with spinner and message
         */
        function showLoadingState(container, message = 'Loading...') {
            container.innerHTML = `
                <div class="loading-state" style="text-align: center; padding: 40px; color: #666;">
                    <div class="loading" style="margin: 0 auto 15px auto;"></div>
                    <div>${message}</div>
                </div>
            `;
        }

        /**
         * Show error state with retry option
         */
        function showErrorState(container, message = 'An error occurred') {
            container.innerHTML = `
                <div class="error-state" style="text-align: center; padding: 40px; color: #d32f2f;">
                    <div style="font-size: 24px; margin-bottom: 10px;">⚠️</div>
                    <div style="margin-bottom: 15px;">${message}</div>
                    <button onclick="refreshFileList()" style="background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">
                        🔄 Try Again
                    </button>
                </div>
            `;
        }

        /**
         * Test function to verify USB communication and MMC operations
         * This tests both the USB layer and MMC read/write functionality
         */
        async function testUSBCommunication() {
            if (!casioUSB) {
                throw new Error('USB communication not initialized');
            }

            console.log('Testing USB communication and MMC operations...');
            
            try {
                // Test 1: Get device status (vendor message in, request 4)
                console.log('Test 1: Getting device status...');
                const statusData = await casioUSB.vendorMessageIn(1, 4, 0, 4);
                const statusBytes = casioUSB.dataViewToUint8Array(statusData);
                console.log('Device status:', Array.from(statusBytes));
                
                // Test 2: Check MMC manager initialization
                console.log('Test 2: Checking MMC manager...');
                if (!mmcManager || !mmcManager.isReady()) {
                    throw new Error('MMC manager not initialized');
                }
                console.log('MMC Total Size:', mmcManager.getTotalSize());
                console.log('MMC ID:', mmcManager.getMMCId());
                
                // Test 3: Test MMC read operation (read first 512 bytes - TOC header)
                console.log('Test 3: Testing MMC read operation...');
                try {
                    const tocHeader = await mmcManager.read(0, 512);
                    console.log(`MMC read test: successfully read ${tocHeader.length} bytes`);
                    console.log('TOC header (first 16 bytes):', Array.from(tocHeader.slice(0, 16)));
                    
                    // Parse track count from TOC header (bytes 4-7, little endian)
                    const trackCountView = new DataView(tocHeader.buffer, 4, 4);
                    const trackCount = trackCountView.getUint32(0, true);
                    console.log('Track count from TOC:', trackCount);
                    
                } catch (error) {
                    console.error('MMC read test failed:', error);
                    throw error;
                }
                
                // Test 4: Test small MMC write operation (write to a safe area)
                console.log('Test 4: Testing MMC write operation...');
                try {
                    // Create a small test buffer (512 bytes of zeros)
                    const testData = new Uint8Array(512);
                    testData.fill(0);
                    
                    // Write to a safe offset (end of MMC - 1KB)
                    const testOffset = mmcManager.getTotalSize() - 1024;
                    console.log(`Writing test data to offset ${testOffset}`);
                    
                    await mmcManager.write(testOffset, testData);
                    console.log('MMC write test: successfully wrote test data');
                    
                    // Read back the data to verify
                    const readBack = await mmcManager.read(testOffset, 512);
                    console.log(`MMC write verification: read back ${readBack.length} bytes`);
                    
                    // Verify the data matches
                    let matches = true;
                    for (let i = 0; i < 512; i++) {
                        if (readBack[i] !== testData[i]) {
                            matches = false;
                            break;
                        }
                    }
                    
                    if (matches) {
                        console.log('MMC write test: data verification successful');
                    } else {
                        console.warn('MMC write test: data verification failed');
                    }
                    
                } catch (error) {
                    console.error('MMC write test failed:', error);
                    // Don't throw here - write test is optional
                    console.warn('MMC write test failed, but this may be expected if watch is write-protected');
                }
                
                console.log('USB communication and MMC operations test completed successfully');
                
            } catch (error) {
                console.error('USB/MMC test failed:', error);
                throw error;
            }
        }

        function updateSpaceInfo(usedBytes, totalBytes) {
            const usedMB = Math.round(usedBytes / (1024 * 1024) * 10) / 10;
            const totalMB = Math.round(totalBytes / (1024 * 1024));
            const usagePercent = (usedBytes / totalBytes) * 100;
            
            document.getElementById('usedSpace').textContent = usedMB;
            document.getElementById('totalSpace').textContent = totalMB;
            document.getElementById('progressFill').style.width = usagePercent + '%';
            
            // Add detailed space information if SpaceManager is available
            if (spaceManager) {
                const spaceInfo = spaceManager.getSpaceInfo();
                const biggestBlockMB = Math.round(spaceInfo.biggestFreeBlock / (1024 * 1024) * 10) / 10;
                const usedBlocks = spaceInfo.usedBlocks;
                
                // Update or create additional space info display
                let detailsElement = document.getElementById('spaceDetails');
                if (!detailsElement) {
                    detailsElement = document.createElement('div');
                    detailsElement.id = 'spaceDetails';
                    detailsElement.style.fontSize = '12px';
                    detailsElement.style.color = '#666';
                    detailsElement.style.marginTop = '5px';
                    document.getElementById('spaceInfo').appendChild(detailsElement);
                }
                
                detailsElement.textContent = `Biggest free block: ${biggestBlockMB} MB • Used blocks: ${usedBlocks}`;
            }
        }

        /**
         * Update real-time space usage display with enhanced information
         * Implements requirement 2.3 and 3.2: Real-time space usage display
         */
        function updateRealTimeSpaceInfo() {
            if (!spaceManager) {
                console.warn('SpaceManager not available for real-time updates');
                return;
            }

            const spaceInfo = spaceManager.getSpaceInfo();
            const usedMB = Math.round(spaceInfo.usedSpace / (1024 * 1024) * 10) / 10;
            const totalMB = Math.round(spaceInfo.totalSize / (1024 * 1024));
            const freeMB = Math.round(spaceInfo.freeSpace / (1024 * 1024) * 10) / 10;
            const biggestBlockMB = Math.round(spaceInfo.biggestFreeBlock / (1024 * 1024) * 10) / 10;
            const usagePercent = spaceInfo.usagePercent;

            // Update main space display
            document.getElementById('usedSpace').textContent = usedMB;
            document.getElementById('totalSpace').textContent = totalMB;
            
            // Animate progress bar update
            const progressFill = document.getElementById('progressFill');
            progressFill.style.transition = 'width 0.5s ease';
            progressFill.style.width = usagePercent + '%';
            
            // Color-code progress bar based on usage
            if (usagePercent > 90) {
                progressFill.style.backgroundColor = '#dc3545'; // Red for critical
            } else if (usagePercent > 75) {
                progressFill.style.backgroundColor = '#ffc107'; // Yellow for warning
            } else {
                progressFill.style.backgroundColor = '#007bff'; // Blue for normal
            }

            // Update or create enhanced space details
            let detailsElement = document.getElementById('spaceDetails');
            if (!detailsElement) {
                detailsElement = document.createElement('div');
                detailsElement.id = 'spaceDetails';
                detailsElement.style.cssText = `
                    font-size: 12px; 
                    color: #666; 
                    margin-top: 8px; 
                    padding: 8px; 
                    background-color: #f8f9fa; 
                    border-radius: 4px;
                    border-left: 3px solid #007bff;
                `;
                document.getElementById('spaceInfo').appendChild(detailsElement);
            }
            
            // Enhanced space information with icons and better formatting
            detailsElement.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span>💾 Free Space: <strong>${freeMB} MB</strong></span>
                    <span>📦 Used Blocks: <strong>${spaceInfo.usedBlocks}</strong></span>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span>🔲 Largest Block: <strong>${biggestBlockMB} MB</strong></span>
                    <span>📊 Usage: <strong>${usagePercent.toFixed(1)}%</strong></span>
                </div>
            `;

            // Add space warning if running low
            if (usagePercent > 90) {
                const warningElement = document.getElementById('spaceWarning') || document.createElement('div');
                warningElement.id = 'spaceWarning';
                warningElement.style.cssText = `
                    margin-top: 8px; 
                    padding: 8px; 
                    background-color: #fff3cd; 
                    border: 1px solid #ffeaa7; 
                    border-radius: 4px; 
                    color: #856404; 
                    font-size: 12px;
                `;
                warningElement.innerHTML = '⚠️ <strong>Low Storage:</strong> Consider deleting some files to free up space.';
                
                if (!document.getElementById('spaceWarning')) {
                    document.getElementById('spaceInfo').appendChild(warningElement);
                }
            } else {
                // Remove warning if space is sufficient
                const warningElement = document.getElementById('spaceWarning');
                if (warningElement) {
                    warningElement.remove();
                }
            }

            console.log(`Space info updated: ${usedMB}/${totalMB} MB used (${usagePercent.toFixed(1)}%), ${freeMB} MB free`);
        }

        /**
         * Port of get_id3v2_len() function from C++ code
         * Detects and returns the length of ID3v2 tags in MP3 files
         * 
         * @param {ArrayBuffer} fileBuffer - MP3 file data
         * @returns {number} - Length of ID3v2 tag in bytes, or 0 if no tag
         */
        function getID3v2Length(fileBuffer) {
            try {
                const data = new Uint8Array(fileBuffer);
                
                // Check if file has at least 10 bytes for ID3v2 header
                if (data.length < 10) {
                    return 0;
                }
                
                // Check for ID3v2 header ("ID3")
                if (data[0] !== 0x49 || data[1] !== 0x44 || data[2] !== 0x33) {
                    return 0; // No ID3v2 header
                }
                
                console.log('Found ID3v2 header!');
                
                let id3len = 10; // Basic header size
                
                // Check flags (byte 5)
                const flags = data[5];
                if (flags & 15) {
                    console.log(`Invalid flags field: 0x${flags.toString(16).padStart(2, '0')}`);
                    return 0;
                }
                
                // Check for footer flag (bit 4)
                if (flags & (1 << 4)) {
                    console.log('ID3v2 Tag has a footer');
                    id3len += 10;
                }
                
                // Read size from bytes 6-9 (synchsafe integer)
                // ID3v2 uses synchsafe integers where bit 7 is always 0
                const sizeByte1 = data[6];
                const sizeByte2 = data[7];
                const sizeByte3 = data[8];
                const sizeByte4 = data[9];
                
                // Convert synchsafe integer to normal integer
                const size = (sizeByte1 & 0x7F) << 21 |
                           (sizeByte2 & 0x7F) << 14 |
                           (sizeByte3 & 0x7F) << 7 |
                           (sizeByte4 & 0x7F);
                
                id3len += size;
                
                console.log(`Got total ID3v2 size of ${id3len} bytes`);
                return id3len;
                
            } catch (error) {
                console.error('Error detecting ID3v2 tag:', error);
                return 0;
            }
        }

        /**
         * Port of filename parsing logic from C++ code
         * Extracts artist and title from filename using "artist - title" format
         * 
         * @param {string} filename - Original filename
         * @returns {Object} - {artist, title} extracted from filename
         */
        function parseFilenameForMetadata(filename) {
            try {
                // Remove file extension (.mp3)
                let title = filename;
                const mp3Index = title.toLowerCase().indexOf('.mp3');
                if (mp3Index !== -1) {
                    title = title.substring(0, mp3Index);
                }
                
                let artist = '';
                
                // Look for "artist - title" pattern
                const dashIndex = title.indexOf(' - ');
                if (dashIndex !== -1) {
                    artist = title.substring(0, dashIndex);
                    title = title.substring(dashIndex + 3);
                }
                
                // Trim whitespace
                artist = artist.trim();
                title = title.trim();
                
                // If no artist found, use "Unknown Artist"
                if (!artist) {
                    artist = 'Unknown Artist';
                }
                
                // If no title found, use filename without extension
                if (!title) {
                    title = filename.replace(/\.mp3$/i, '') || 'Unknown Title';
                }
                
                console.log(`Parsed filename "${filename}" -> Artist: "${artist}", Title: "${title}"`);
                
                return { artist, title };
                
            } catch (error) {
                console.error('Error parsing filename:', error);
                return { 
                    artist: 'Unknown Artist', 
                    title: filename.replace(/\.mp3$/i, '') || 'Unknown Title' 
                };
            }
        }

        /**
         * Strip ID3v2 tags from MP3 file data
         * 
         * @param {ArrayBuffer} fileBuffer - Original MP3 file data
         * @returns {ArrayBuffer} - MP3 data with ID3v2 tags removed
         */
        function stripID3v2Tags(fileBuffer) {
            const id3Length = getID3v2Length(fileBuffer);
            
            if (id3Length === 0) {
                console.log('No ID3v2 tags found, returning original file');
                return fileBuffer;
            }
            
            console.log(`Stripping ${id3Length} bytes of ID3v2 tags`);
            
            // Return the file data without the ID3v2 tag
            return fileBuffer.slice(id3Length);
        }

        /**
         * Upload a single file to the watch
         * 
         * @param {File} file - File object to upload
         * @param {Function} progressCallback - Callback for progress updates
         * @returns {Promise<boolean>} - true if upload successful
         */
        async function uploadSingleFile(file, progressCallback) {
            try {
                console.log(`Starting upload of "${file.name}" (${file.size} bytes)`);
                
                // Update progress
                progressCallback('reading', 0);
                
                // Read file data
                const fileBuffer = await file.arrayBuffer();
                console.log(`Read ${fileBuffer.byteLength} bytes from file`);
                
                // Strip ID3v2 tags
                progressCallback('processing', 10);
                const strippedBuffer = stripID3v2Tags(fileBuffer);
                const finalSize = strippedBuffer.byteLength;
                
                console.log(`File size after ID3v2 stripping: ${finalSize} bytes`);
                
                // Parse filename for metadata
                const metadata = parseFilenameForMetadata(file.name);
                
                // Check if there's enough space
                progressCallback('checking', 20);
                const spaceInfo = spaceManager.getSpaceInfo();
                if (finalSize > spaceInfo.biggestFreeBlock) {
                    throw new Error(`Not enough space. File needs ${Math.round(finalSize / 1024)} KB, but only ${Math.round(spaceInfo.biggestFreeBlock / 1024)} KB available in largest block.`);
                }
                
                // Find space for the file
                const fileOffset = tocManager.findSpace(finalSize);
                if (fileOffset === -1) {
                    throw new Error(`Could not find space for file (${Math.round(finalSize / 1024)} KB needed)`);
                }
                
                console.log(`Allocated space at offset ${fileOffset} for ${finalSize} bytes`);
                
                // Write file data to MMC with retry logic
                progressCallback('uploading', 30);
                const fileData = new Uint8Array(strippedBuffer);
                
                // Write in chunks to show progress
                const chunkSize = 32768; // 32KB chunks
                let bytesWritten = 0;
                
                while (bytesWritten < finalSize) {
                    const remainingBytes = finalSize - bytesWritten;
                    const currentChunkSize = Math.min(chunkSize, remainingBytes);
                    
                    const chunk = fileData.slice(bytesWritten, bytesWritten + currentChunkSize);
                    
                    // Use retry logic for MMC write operations
                    await retryOperation(async () => {
                        const writeResult = await mmcManager.write(fileOffset + bytesWritten, chunk);
                        if (writeResult !== 0) {
                            throw new Error(`MMC write failed at offset ${fileOffset + bytesWritten}`);
                        }
                    }, ErrorCategories.DEVICE_OPERATION, `MMC write chunk at ${fileOffset + bytesWritten}`);
                    
                    bytesWritten += currentChunkSize;
                    
                    // Update progress (30% to 80% for writing)
                    const writeProgress = 30 + (bytesWritten / finalSize) * 50;
                    progressCallback('uploading', writeProgress);
                    
                    console.log(`Wrote ${bytesWritten}/${finalSize} bytes (${Math.round(writeProgress)}%)`);
                }
                
                console.log(`Successfully wrote ${bytesWritten} bytes to MMC`);
                
                // Add file to TOC
                progressCallback('updating', 85);
                tocManager.addTrack(fileOffset, finalSize, metadata.title, metadata.artist, '');
                
                // Generate and write updated TOC with retry logic
                progressCallback('finalizing', 90);
                await retryOperation(async () => {
                    const generateResult = await tocManager.generateFromArray();
                    if (generateResult !== 0) {
                        throw new Error('Failed to generate TOC from track list');
                    }
                    
                    const writeResult = await tocManager.writeToWatch();
                    if (writeResult !== 0) {
                        throw new Error('Failed to write TOC to watch');
                    }
                }, ErrorCategories.DEVICE_OPERATION, 'TOC update');
                
                progressCallback('complete', 100);
                console.log(`Successfully uploaded "${file.name}" as "${metadata.title}" by "${metadata.artist}"`);
                
                return true;
                
            } catch (error) {
                console.error(`Upload failed for "${file.name}":`, error);
                progressCallback('error', 0, error.message);
                throw error;
            }
        }

        /**
         * Upload selected files to the watch
         */
        async function uploadSelectedFiles() {
            const fileInput = document.getElementById('fileInput');
            const files = Array.from(fileInput.files);
            
            if (!files.length) {
                showError('Please select files to upload', ErrorCategories.FILE_VALIDATION);
                return;
            }
            
            if (!connected || !device || !tocManager || !mmcManager || !spaceManager) {
                showError('Watch not connected or managers not initialized', ErrorCategories.CONNECTION);
                return;
            }

            // Validate all files before starting upload
            const validation = validateFiles(files);
            
            // Show validation warnings
            if (validation.warnings.length > 0) {
                showWarning(`File warnings: ${validation.warnings.join(', ')}`);
            }
            
            // Handle invalid files
            if (validation.invalid.length > 0) {
                const errorMessages = validation.invalid.map(item => 
                    `${item.file.name}: ${item.errors.join(', ')}`
                ).join('\n');
                
                showError(`Invalid files found:\n${errorMessages}`, ErrorCategories.FILE_VALIDATION);
                return;
            }
            
            // Check total space requirements
            const spaceInfo = spaceManager.getSpaceInfo();
            if (validation.totalSize > spaceInfo.freeSpace) {
                const neededMB = Math.round(validation.totalSize / 1024 / 1024 * 10) / 10;
                const availableMB = Math.round(spaceInfo.freeSpace / 1024 / 1024 * 10) / 10;
                showError(`Not enough space. Need ${neededMB}MB but only ${availableMB}MB available.`, ErrorCategories.SPACE_MANAGEMENT);
                return;
            }
            
            // Use only valid files
            const validFiles = validation.valid;

            const uploadBtn = document.getElementById('uploadBtn');
            const originalText = uploadBtn.textContent;
            const uploadProgress = document.getElementById('uploadProgress');
            const uploadFileList = document.getElementById('uploadFileList');
            
            try {
                // Disable upload button and show progress
                uploadBtn.disabled = true;
                uploadBtn.textContent = 'Uploading...';
                uploadProgress.classList.add('visible');
                uploadFileList.innerHTML = '';
                hideMessages();
                
                // Create progress tracking for each file
                const fileProgressElements = new Map();
                
                // Create UI elements for each valid file
                validFiles.forEach((file, index) => {
                    const fileElement = document.createElement('div');
                    fileElement.className = 'upload-file-item';
                    fileElement.innerHTML = `
                        <div class="upload-file-info">
                            <div class="upload-file-name">${file.name}</div>
                            <div class="upload-file-details">${Math.round(file.size / 1024)} KB</div>
                            <div class="upload-file-progress">
                                <div class="upload-file-progress-fill" style="width: 0%"></div>
                            </div>
                        </div>
                        <div class="upload-status" id="status-${index}">Waiting...</div>
                    `;
                    uploadFileList.appendChild(fileElement);
                    fileProgressElements.set(index, fileElement);
                });
                
                let successCount = 0;
                let errorCount = 0;
                
                // Upload valid files one by one
                for (let i = 0; i < validFiles.length; i++) {
                    const file = validFiles[i];
                    const fileElement = fileProgressElements.get(i);
                    const statusElement = fileElement.querySelector(`#status-${i}`);
                    const progressFill = fileElement.querySelector('.upload-file-progress-fill');
                    
                    try {
                        // Progress callback for this file
                        const progressCallback = (stage, percent, errorMsg) => {
                            if (stage === 'error') {
                                statusElement.textContent = `Error: ${errorMsg}`;
                                statusElement.className = 'upload-status error';
                                progressFill.style.width = '0%';
                            } else if (stage === 'complete') {
                                statusElement.textContent = 'Complete';
                                statusElement.className = 'upload-status success';
                                progressFill.style.width = '100%';
                            } else {
                                const stageNames = {
                                    'reading': 'Reading file...',
                                    'processing': 'Processing...',
                                    'checking': 'Checking space...',
                                    'uploading': 'Uploading...',
                                    'updating': 'Updating TOC...',
                                    'finalizing': 'Finalizing...'
                                };
                                statusElement.textContent = stageNames[stage] || 'Processing...';
                                statusElement.className = 'upload-status uploading';
                                progressFill.style.width = percent + '%';
                            }
                        };
                        
                        // Upload the file
                        await uploadSingleFile(file, progressCallback);
                        successCount++;
                        
                    } catch (error) {
                        console.error(`Failed to upload ${file.name}:`, error);
                        errorCount++;
                    }
                }
                
                // Show final results
                if (successCount > 0) {
                    showSuccess(`Successfully uploaded ${successCount} file(s)${errorCount > 0 ? ` (${errorCount} failed)` : ''}`);
                    
                    // Refresh file list to show new files
                    await refreshFileList();
                    
                    // Clear file input
                    fileInput.value = '';
                    updateUploadButtonState();
                } else {
                    showError(`All uploads failed (${errorCount} files)`);
                }
                
            } catch (error) {
                console.error('Upload process failed:', error);
                showError('Upload failed: ' + error.message);
            } finally {
                uploadBtn.disabled = false;
                uploadBtn.textContent = originalText;
            }
        }

        /**
         * Update upload button state based on file selection
         */
        function updateUploadButtonState() {
            const fileInput = document.getElementById('fileInput');
            const uploadBtn = document.getElementById('uploadBtn');
            
            uploadBtn.disabled = !fileInput.files.length || !connected;
        }

        /**
         * Refresh UI after upload/delete operations
         * Implements requirement 2.3 and 3.2: UI refresh after operations
         */
        async function refreshUIAfterOperation(operationType, fileName = '') {
            try {
                console.log(`Refreshing UI after ${operationType} operation${fileName ? ` for ${fileName}` : ''}`);
                
                // Update file list with loading state
                await refreshFileList();
                
                // Update real-time space information
                updateRealTimeSpaceInfo();
                
                // Update upload button state
                updateUploadButtonState();
                
                // Show success feedback with animation
                const spaceInfo = document.getElementById('spaceInfo');
                if (spaceInfo) {
                    spaceInfo.style.transition = 'all 0.3s ease';
                    spaceInfo.style.transform = 'scale(1.02)';
                    setTimeout(() => {
                        spaceInfo.style.transform = 'scale(1)';
                    }, 300);
                }
                
                console.log(`UI refresh completed for ${operationType} operation`);
                
            } catch (error) {
                console.error(`Failed to refresh UI after ${operationType}:`, error);
                showError(`UI refresh failed after ${operationType}: ${error.message}`);
            }
        }

        /**
         * Add loading indicators to buttons during operations
         * Implements requirement: Loading states and progress indicators
         */
        function setButtonLoadingState(buttonId, isLoading, loadingText = 'Loading...', originalText = '') {
            const button = document.getElementById(buttonId);
            if (!button) return;
            
            if (isLoading) {
                button.disabled = true;
                button.dataset.originalText = button.textContent;
                button.innerHTML = `<span class="loading"></span> ${loadingText}`;
            } else {
                button.disabled = false;
                button.innerHTML = originalText || button.dataset.originalText || button.textContent;
                delete button.dataset.originalText;
            }
        }

        /**
         * Show operation progress with visual feedback
         * Implements requirement: Progress indicators for operations
         */
        function showOperationProgress(container, message, progress = 0) {
            const progressElement = container.querySelector('.operation-progress') || document.createElement('div');
            progressElement.className = 'operation-progress';
            progressElement.style.cssText = `
                margin: 10px 0;
                padding: 10px;
                background-color: #f8f9fa;
                border-radius: 4px;
                border-left: 3px solid #007bff;
            `;
            
            progressElement.innerHTML = `
                <div style="display: flex; align-items: center; margin-bottom: 5px;">
                    <span class="loading" style="margin-right: 10px;"></span>
                    <span>${message}</span>
                </div>
                <div style="width: 100%; height: 4px; background-color: #e0e0e0; border-radius: 2px;">
                    <div style="width: ${progress}%; height: 100%; background-color: #007bff; border-radius: 2px; transition: width 0.3s ease;"></div>
                </div>
            `;
            
            if (!container.querySelector('.operation-progress')) {
                container.appendChild(progressElement);
            }
        }

        /**
         * Hide operation progress indicators
         */
        function hideOperationProgress(container) {
            const progressElement = container.querySelector('.operation-progress');
            if (progressElement) {
                progressElement.remove();
            }
        }

        /**
         * Delete a file from the watch
         * Implements file removal logic with TOC updates and confirmation dialog
         * 
         * @param {number} index - Index of the file to delete (0-based)
         */
        async function deleteFile(index) {
            if (!connected || !device || !tocManager || !mmcManager || !spaceManager) {
                showError('Watch not connected or managers not initialized', ErrorCategories.CONNECTION);
                return;
            }

            try {
                // Get current track list
                const tracks = tocManager.getTrackList();
                
                if (index < 0 || index >= tracks.length) {
                    showError('Invalid file index', ErrorCategories.FILE_VALIDATION);
                    return;
                }
                
                const track = tracks[index];
                const displayTitle = track.title || `Track ${index + 1}`;
                const displayArtist = track.artist || 'Unknown Artist';
                const sizeKB = Math.round(track.size / 1024);
                
                // Show confirmation dialog with file details
                const confirmMessage = `Are you sure you want to delete this file?\n\n` +
                                     `Title: ${displayTitle}\n` +
                                     `Artist: ${displayArtist}\n` +
                                     `Size: ${sizeKB} KB\n\n` +
                                     `This action cannot be undone.`;
                
                if (!confirm(confirmMessage)) {
                    return; // User cancelled
                }
                
                console.log(`Deleting file: "${displayTitle}" by "${displayArtist}" (index ${index})`);
                
                // Disable all buttons during deletion
                const deleteButtons = document.querySelectorAll('.delete-btn');
                const refreshBtn = document.getElementById('refreshBtn');
                const uploadBtn = document.getElementById('uploadBtn');
                
                deleteButtons.forEach(btn => btn.disabled = true);
                if (refreshBtn) refreshBtn.disabled = true;
                if (uploadBtn) uploadBtn.disabled = true;
                
                // Show loading state
                hideMessages();
                const loadingMessage = document.createElement('div');
                loadingMessage.style.cssText = 'text-align: center; padding: 10px; color: #007bff;';
                loadingMessage.innerHTML = `<span class="loading"></span> Deleting "${displayTitle}"...`;
                document.getElementById('fileList').prepend(loadingMessage);
                
                try {
                    // Remove track from TOC manager (this also frees the space)
                    tocManager.removeTrack(index);
                    console.log(`Removed track ${index} from TOC`);
                    
                    // Generate and write updated TOC with retry logic
                    await retryOperation(async () => {
                        const generateResult = await tocManager.generateFromArray();
                        if (generateResult !== 0) {
                            throw new Error('Failed to generate updated TOC');
                        }
                        console.log('Generated updated TOC');
                        
                        const writeResult = await tocManager.writeToWatch();
                        if (writeResult !== 0) {
                            throw new Error('Failed to write updated TOC to watch');
                        }
                        console.log('Successfully wrote updated TOC to watch');
                    }, ErrorCategories.DEVICE_OPERATION, 'file deletion TOC update');
                    
                    // Show success message
                    showSuccess(`Successfully deleted "${displayTitle}" by "${displayArtist}"`, true);
                    
                    // Refresh the file list to show updated state with retry logic
                    await retryOperation(
                        () => refreshFileList(),
                        ErrorCategories.DEVICE_OPERATION,
                        'file list refresh after deletion'
                    );
                    
                    console.log(`File deletion completed successfully. Freed ${sizeKB} KB of space.`);
                    
                } catch (error) {
                    console.error('File deletion failed:', error);
                    
                    let category = ErrorCategories.DEVICE_OPERATION;
                    if (error.message.includes('TOC')) {
                        category = ErrorCategories.DEVICE_OPERATION;
                    } else if (error.message.includes('timeout')) {
                        category = ErrorCategories.USB_COMMUNICATION;
                    }
                    
                    showError(`Failed to delete file: ${error.message}`, category, () => deleteFile(index));
                    
                    // Try to refresh file list to restore consistent state
                    try {
                        await retryOperation(
                            () => refreshFileList(),
                            ErrorCategories.DEVICE_OPERATION,
                            'file list refresh after deletion error'
                        );
                    } catch (refreshError) {
                        console.error('Failed to refresh file list after deletion error:', refreshError);
                    }
                } finally {
                    // Remove loading message
                    if (loadingMessage && loadingMessage.parentNode) {
                        loadingMessage.parentNode.removeChild(loadingMessage);
                    }
                    
                    // Re-enable buttons
                    deleteButtons.forEach(btn => btn.disabled = false);
                    if (refreshBtn) refreshBtn.disabled = false;
                    if (uploadBtn) uploadBtn.disabled = false;
                }
                
            } catch (error) {
                console.error('Delete file error:', error);
                showError('Failed to delete file: ' + error.message, ErrorCategories.DEVICE_OPERATION, () => deleteFile(index));
            }
        }

        /**
         * Enhanced Error Handling and User Feedback System
         * Provides comprehensive error messages, retry logic, and user-friendly feedback
         */

        // Error categories for better user messaging
        const ErrorCategories = {
            CONNECTION: 'connection',
            USB_COMMUNICATION: 'usb',
            FILE_VALIDATION: 'validation',
            SPACE_MANAGEMENT: 'space',
            DEVICE_OPERATION: 'device',
            NETWORK: 'network',
            BROWSER_SUPPORT: 'browser'
        };

        // Common error patterns and their user-friendly messages
        const ErrorMessages = {
            // Connection errors
            'device not found': 'Watch not detected. Please ensure your Casio WMP-1 is connected via USB and try again.',
            'permission denied': 'USB access denied. Please click "Connect to Watch" and grant permission when prompted.',
            'device disconnected': 'Watch was disconnected. Please reconnect your device and try again.',
            'no device selected': 'No device selected. Please connect your watch first.',
            
            // USB communication errors
            'timeout': 'Communication timeout. The watch may be busy or disconnected. Please try again.',
            'transfer failed': 'USB transfer failed. Please check the connection and try again.',
            'bulk read failed': 'Failed to read data from watch. Please check the USB connection.',
            'bulk write failed': 'Failed to write data to watch. Please check the USB connection.',
            'vendor message': 'Communication error with watch. Please reconnect and try again.',
            
            // File validation errors
            'not an mp3': 'Only MP3 files are supported. Please select MP3 files only.',
            'file too large': 'File is too large for the available space on your watch.',
            'invalid file': 'Invalid file format. Please ensure the file is a valid MP3.',
            'no files selected': 'Please select at least one MP3 file to upload.',
            
            // Space management errors
            'insufficient space': 'Not enough space on watch. Please delete some files first.',
            'no space found': 'Cannot find suitable space for file. Try deleting some files first.',
            'space allocation failed': 'Failed to allocate space for file. Please try again.',
            
            // Device operation errors
            'toc read failed': 'Failed to read file list from watch. Please try reconnecting.',
            'toc write failed': 'Failed to update file list on watch. Please try again.',
            'mmc read failed': 'Failed to read data from watch memory. Please check connection.',
            'mmc write failed': 'Failed to write data to watch memory. Please try again.',
            
            // Browser support errors
            'webusb not supported': 'Your browser doesn\'t support WebUSB. Please use Chrome or Edge with HTTPS.',
            'https required': 'WebUSB requires HTTPS. Please access this page over a secure connection.'
        };

        // Retry configuration for different error types
        const RetryConfig = {
            [ErrorCategories.USB_COMMUNICATION]: { maxRetries: 3, delay: 1000, backoff: 1.5 },
            [ErrorCategories.DEVICE_OPERATION]: { maxRetries: 2, delay: 2000, backoff: 2.0 },
            [ErrorCategories.CONNECTION]: { maxRetries: 1, delay: 3000, backoff: 1.0 },
            default: { maxRetries: 1, delay: 1000, backoff: 1.0 }
        };

        /**
         * Enhanced error display with categorization and retry options
         */
        function showError(message, category = null, retryCallback = null) {
            const errorDiv = document.getElementById('errorMessage');
            const successDiv = document.getElementById('successMessage');
            
            // Get user-friendly message
            const friendlyMessage = getUserFriendlyErrorMessage(message, category);
            
            // Create error content with optional retry button
            let errorContent = friendlyMessage;
            if (retryCallback && category !== ErrorCategories.BROWSER_SUPPORT) {
                errorContent += `<br><button onclick="(${retryCallback.toString()})()" style="margin-top: 10px; padding: 5px 10px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer;">Try Again</button>`;
            }
            
            errorDiv.innerHTML = errorContent;
            errorDiv.style.display = 'block';
            successDiv.style.display = 'none';
            
            document.getElementById('connectionSection').classList.add('error');
            
            // Log detailed error for debugging
            console.error('Error:', { original: message, category, friendly: friendlyMessage });
        }

        /**
         * Enhanced success message display
         */
        function showSuccess(message, autoHide = false) {
            const errorDiv = document.getElementById('errorMessage');
            const successDiv = document.getElementById('successMessage');
            
            successDiv.innerHTML = message;
            successDiv.style.display = 'block';
            errorDiv.style.display = 'none';
            
            document.getElementById('connectionSection').classList.remove('error');
            
            // Auto-hide success messages after 5 seconds if requested
            if (autoHide) {
                setTimeout(() => {
                    if (successDiv.style.display === 'block' && successDiv.innerHTML === message) {
                        hideMessages();
                    }
                }, 5000);
            }
        }

        /**
         * Show warning messages (non-blocking)
         */
        function showWarning(message) {
            const errorDiv = document.getElementById('errorMessage');
            const successDiv = document.getElementById('successMessage');
            
            errorDiv.innerHTML = `⚠️ ${message}`;
            errorDiv.style.display = 'block';
            errorDiv.style.backgroundColor = '#fff3cd';
            errorDiv.style.color = '#856404';
            successDiv.style.display = 'none';
            
            // Reset to error styling after 3 seconds
            setTimeout(() => {
                errorDiv.style.backgroundColor = '#ffebee';
                errorDiv.style.color = '#d32f2f';
            }, 3000);
        }

        /**
         * Convert technical error messages to user-friendly ones
         */
        function getUserFriendlyErrorMessage(message, category) {
            const lowerMessage = message.toLowerCase();
            
            // Check for specific error patterns
            for (const [pattern, friendlyMsg] of Object.entries(ErrorMessages)) {
                if (lowerMessage.includes(pattern)) {
                    return friendlyMsg;
                }
            }
            
            // Category-specific fallbacks
            switch (category) {
                case ErrorCategories.CONNECTION:
                    return 'Connection failed. Please check that your watch is connected and try again.';
                case ErrorCategories.USB_COMMUNICATION:
                    return 'Communication error with watch. Please check the USB connection and try again.';
                case ErrorCategories.FILE_VALIDATION:
                    return 'File validation failed. Please check that you\'re uploading valid MP3 files.';
                case ErrorCategories.SPACE_MANAGEMENT:
                    return 'Storage space issue. Please delete some files to make room.';
                case ErrorCategories.DEVICE_OPERATION:
                    return 'Watch operation failed. Please try again or reconnect your device.';
                case ErrorCategories.BROWSER_SUPPORT:
                    return 'Browser compatibility issue. Please use Chrome or Edge with HTTPS.';
                default:
                    // Return original message if no friendly version found
                    return message;
            }
        }

        /**
         * Generic retry wrapper with exponential backoff
         */
        async function retryOperation(operation, category = 'default', context = '') {
            const config = RetryConfig[category] || RetryConfig.default;
            let lastError;
            
            for (let attempt = 0; attempt <= config.maxRetries; attempt++) {
                try {
                    if (attempt > 0) {
                        const delay = config.delay * Math.pow(config.backoff, attempt - 1);
                        console.log(`Retry attempt ${attempt}/${config.maxRetries} for ${context} after ${delay}ms delay`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                    
                    return await operation();
                } catch (error) {
                    lastError = error;
                    console.warn(`Attempt ${attempt + 1}/${config.maxRetries + 1} failed for ${context}:`, error.message);
                    
                    // Don't retry certain types of errors
                    if (isNonRetryableError(error)) {
                        break;
                    }
                }
            }
            
            throw lastError;
        }

        /**
         * Determine if an error should not be retried
         */
        function isNonRetryableError(error) {
            const message = error.message.toLowerCase();
            const nonRetryablePatterns = [
                'not supported',
                'permission denied',
                'invalid file',
                'file too large',
                'insufficient space',
                'no space found',
                'webusb',
                'https required'
            ];
            
            return nonRetryablePatterns.some(pattern => message.includes(pattern));
        }

        /**
         * File validation with detailed error messages
         */
        function validateFile(file) {
            const errors = [];
            const warnings = [];
            
            // Check file type
            if (!file.type.includes('audio') && !file.name.toLowerCase().endsWith('.mp3')) {
                errors.push(`"${file.name}" is not an MP3 file`);
            }
            
            // Check file size (reasonable limits)
            const maxSize = 10 * 1024 * 1024; // 10MB max per file
            const minSize = 1024; // 1KB minimum
            
            if (file.size > maxSize) {
                errors.push(`"${file.name}" is too large (${Math.round(file.size / 1024 / 1024)}MB). Maximum size is 10MB.`);
            }
            
            if (file.size < minSize) {
                errors.push(`"${file.name}" is too small (${file.size} bytes). Minimum size is 1KB.`);
            }
            
            // Check filename
            if (file.name.length > 100) {
                warnings.push(`"${file.name}" has a very long filename which may cause issues`);
            }
            
            // Check for special characters that might cause issues
            if (/[<>:"|?*]/.test(file.name)) {
                warnings.push(`"${file.name}" contains special characters that may cause issues`);
            }
            
            return { errors, warnings, valid: errors.length === 0 };
        }

        /**
         * Batch file validation
         */
        function validateFiles(files) {
            const results = {
                valid: [],
                invalid: [],
                warnings: [],
                totalSize: 0
            };
            
            for (const file of files) {
                const validation = validateFile(file);
                
                if (validation.valid) {
                    results.valid.push(file);
                    results.totalSize += file.size;
                } else {
                    results.invalid.push({ file, errors: validation.errors });
                }
                
                results.warnings.push(...validation.warnings);
            }
            
            return results;
        }

        function hideMessages() {
            document.getElementById('errorMessage').style.display = 'none';
            document.getElementById('successMessage').style.display = 'none';
            document.getElementById('connectionSection').classList.remove('error');
        }

        // Handle device disconnection
        navigator.usb.addEventListener('disconnect', event => {
            if (event.device === device) {
                connected = false;
                deviceState.connected = false;
                deviceState.device = null;
                device = null;
                casioUSB = null;
                mmcManager = null;
                tocManager = null;
                spaceManager = null;
                
                updateConnectionUI(false);
                showError('Watch was disconnected. Please reconnect to continue.', ErrorCategories.CONNECTION, connectToWatch);
                
                // Hide file section
                document.getElementById('fileSection').classList.remove('visible');
            }
        });

        // Wrapper function for testing USB communication and MMC operations from UI
        async function testUSBFromUI() {
            if (!connected || !casioUSB || !mmcManager || !tocManager) {
                showError('Watch not connected or managers not initialized');
                return;
            }

            const testBtn = document.getElementById('testUSBBtn');
            const originalText = testBtn.textContent;
            
            try {
                testBtn.disabled = true;
                testBtn.textContent = 'Testing...';
                hideMessages();
                
                // Test basic USB communication and MMC operations
                await testUSBCommunication();
                
                // Test TOC operations
                console.log('=== Testing TOC Operations ===');
                
                // Test TOC read
                console.log('Testing TOC read...');
                const readResult = await tocManager.readFromWatch();
                if (readResult !== 0) {
                    throw new Error('TOC read test failed');
                }
                console.log('✓ TOC read test passed');
                
                // Test TOC parse
                console.log('Testing TOC parse...');
                const parseResult = await tocManager.parseIntoArray();
                if (parseResult !== 0) {
                    throw new Error('TOC parse test failed');
                }
                console.log('✓ TOC parse test passed');
                console.log(`  Found ${tocManager.trackCount} tracks`);
                
                // Test space calculations
                console.log('Testing space calculations...');
                tocManager.calcFreeSpace();
                const spaceInfo = spaceManager.getSpaceInfo();
                console.log('✓ Space calculation test passed');
                console.log(`  Total free: ${Math.round(spaceInfo.freeSpace / 1024)} KB`);
                console.log(`  Biggest block: ${Math.round(spaceInfo.biggestFreeBlock / 1024)} KB`);
                
                // Test TOC generation (round-trip test)
                console.log('Testing TOC generation...');
                const generateResult = await tocManager.generateFromArray();
                if (generateResult !== 0) {
                    throw new Error('TOC generation test failed');
                }
                console.log('✓ TOC generation test passed');
                
                // Display track information
                const tracks = tocManager.getTrackList();
                console.log('Track list:');
                tracks.forEach((track, index) => {
                    console.log(`  ${index + 1}. "${track.title}" by "${track.artist}" (${Math.round(track.size / 1024)} KB)`);
                });
                
                showSuccess('All tests passed! USB, MMC, and TOC operations working correctly. Check console for details.');
                
            } catch (error) {
                console.error('Test failed:', error);
                showError('Test failed: ' + error.message);
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = originalText;
            }
        }



        /**
         * Test space management functionality
         * This function demonstrates the space allocation, tracking, and reclamation features
         */
        function testSpaceManagement() {
            console.log('=== Testing Space Management System ===');
            
            try {
                // Create a test SpaceManager if one doesn't exist
                let testSpaceManager = spaceManager || new SpaceManager();
                
                // Test 1: Initial state
                console.log('1. Testing initial state...');
                let spaceInfo = testSpaceManager.getSpaceInfo();
                console.log(`   Initial free space: ${Math.round(spaceInfo.freeSpace / 1024)} KB`);
                console.log(`   Initial biggest block: ${Math.round(spaceInfo.biggestFreeBlock / 1024)} KB`);
                console.log(`   ✓ Initial state test passed`);
                
                // Test 2: Space allocation
                console.log('2. Testing space allocation...');
                const testFileSize = 1024 * 100; // 100KB test file
                const allocatedOffset = testSpaceManager.findSpace(testFileSize);
                if (allocatedOffset !== -1) {
                    console.log(`   ✓ Found space for 100KB file at offset ${allocatedOffset}`);
                    testSpaceManager.useSpace(allocatedOffset, testFileSize);
                    console.log(`   ✓ Allocated 100KB at offset ${allocatedOffset}`);
                } else {
                    console.log(`   ✗ No space found for 100KB file`);
                    throw new Error('Space allocation failed');
                }
                
                // Test 3: Space tracking
                console.log('3. Testing space tracking...');
                spaceInfo = testSpaceManager.getSpaceInfo();
                console.log(`   Used blocks: ${spaceInfo.usedBlocks}`);
                console.log(`   Free space after allocation: ${Math.round(spaceInfo.freeSpace / 1024)} KB`);
                console.log(`   ✓ Space tracking test passed`);
                
                // Test 4: Multiple allocations
                console.log('4. Testing multiple allocations...');
                const file2Size = 1024 * 50; // 50KB test file
                const offset2 = testSpaceManager.findSpace(file2Size);
                if (offset2 !== -1) {
                    testSpaceManager.useSpace(offset2, file2Size);
                    console.log(`   ✓ Allocated second file (50KB) at offset ${offset2}`);
                } else {
                    console.log(`   ✗ No space found for second file`);
                }
                
                const file3Size = 1024 * 200; // 200KB test file
                const offset3 = testSpaceManager.findSpace(file3Size);
                if (offset3 !== -1) {
                    testSpaceManager.useSpace(offset3, file3Size);
                    console.log(`   ✓ Allocated third file (200KB) at offset ${offset3}`);
                } else {
                    console.log(`   ✗ No space found for third file`);
                }
                
                spaceInfo = testSpaceManager.getSpaceInfo();
                console.log(`   Total used blocks: ${spaceInfo.usedBlocks}`);
                console.log(`   ✓ Multiple allocation test passed`);
                
                // Test 5: Space reclamation
                console.log('5. Testing space reclamation...');
                const freed = testSpaceManager.freeSpace(allocatedOffset);
                if (freed) {
                    console.log(`   ✓ Successfully freed space at offset ${allocatedOffset}`);
                    spaceInfo = testSpaceManager.getSpaceInfo();
                    console.log(`   Free space after reclamation: ${Math.round(spaceInfo.freeSpace / 1024)} KB`);
                    console.log(`   Used blocks after deletion: ${spaceInfo.usedBlocks}`);
                } else {
                    console.log(`   ✗ Failed to free space at offset ${allocatedOffset}`);
                    throw new Error('Space reclamation failed');
                }
                
                // Test 6: Best-fit allocation
                console.log('6. Testing best-fit allocation...');
                const smallFileSize = 1024 * 80; // 80KB - should fit in the freed 100KB space
                const bestFitOffset = testSpaceManager.findSpace(smallFileSize);
                if (bestFitOffset === allocatedOffset) {
                    console.log(`   ✓ Best-fit allocation working: found space at original offset ${bestFitOffset}`);
                } else {
                    console.log(`   ✓ Found space at offset ${bestFitOffset} (different from original, but valid)`);
                }
                
                // Test 7: Space integrity validation
                console.log('7. Testing space integrity...');
                const validation = testSpaceManager.validateSpaceIntegrity();
                if (validation.valid) {
                    console.log(`   ✓ Space integrity check passed (${validation.totalBlocks} blocks)`);
                } else {
                    console.log(`   ✗ Space integrity issues found:`);
                    validation.issues.forEach(issue => console.log(`     - ${issue}`));
                    throw new Error('Space integrity validation failed');
                }
                
                // Test 8: 512-byte alignment
                console.log('8. Testing 512-byte alignment...');
                const unalignedSize = 1000; // Not a multiple of 512
                const alignedOffset = testSpaceManager.findSpace(unalignedSize);
                if (alignedOffset !== -1) {
                    testSpaceManager.useSpace(alignedOffset, unalignedSize);
                    const blocks = testSpaceManager.getUsedSpaceBlocks();
                    const addedBlock = blocks.find(block => block.offset === alignedOffset);
                    if (addedBlock && addedBlock.size % 512 === 0) {
                        console.log(`   ✓ 512-byte alignment working: ${unalignedSize} bytes aligned to ${addedBlock.size} bytes`);
                    } else {
                        throw new Error('512-byte alignment failed');
                    }
                }
                
                console.log('=== All Space Management Tests Passed! ===');
                showSuccess('Space Management System test completed successfully! Check console for details.');
                
            } catch (error) {
                console.error('Space Management test failed:', error);
                showError('Space Management test failed: ' + error.message);
            }
        }

        /**
         * Start periodic space info updates when connected
         * Implements real-time space usage display updates
         */
        function startPeriodicSpaceUpdates() {
            // Clear any existing interval
            if (window.spaceUpdateInterval) {
                clearInterval(window.spaceUpdateInterval);
            }
            
            // Update space info every 5 seconds when connected
            window.spaceUpdateInterval = setInterval(() => {
                if (connected && spaceManager) {
                    updateRealTimeSpaceInfo();
                }
            }, 5000);
            
            console.log('Started periodic space info updates');
        }

        /**
         * Stop periodic space info updates
         */
        function stopPeriodicSpaceUpdates() {
            if (window.spaceUpdateInterval) {
                clearInterval(window.spaceUpdateInterval);
                window.spaceUpdateInterval = null;
                console.log('Stopped periodic space info updates');
            }
        }

        // Start periodic updates when page loads
        window.addEventListener('DOMContentLoaded', function() {
            // Start periodic updates (will only update when connected)
            startPeriodicSpaceUpdates();
        });

        // Stop periodic updates when page unloads
        window.addEventListener('beforeunload', function() {
            stopPeriodicSpaceUpdates();
        });

        /**
         * File Manager - Provides file management functionality for testing
         * This is a simplified version for testing purposes
         */
        class FileManager {
            constructor(tocManager, mmcManager, spaceManager) {
                this.tocManager = tocManager;
                this.mmcManager = mmcManager;
                this.spaceManager = spaceManager;
            }

            /**
             * List files on the watch
             */
            async listFiles() {
                if (!this.tocManager) {
                    return [];
                }
                return this.tocManager.getTrackList();
            }

            /**
             * Strip ID3v2 tags from MP3 data (port of get_id3v2_len from C++)
             */
            stripID3v2(arrayBuffer) {
                const data = new Uint8Array(arrayBuffer);
                
                if (data.length < 10) {
                    return data; // Too small to have ID3v2 header
                }
                
                // Check for ID3v2 header "ID3"
                if (data[0] !== 0x49 || data[1] !== 0x44 || data[2] !== 0x33) {
                    return data; // No ID3v2 header
                }
                
                console.log('Found ID3v2 header, stripping...');
                
                let id3len = 10; // Basic header size
                const flags = data[5];
                
                if (flags & 15) {
                    console.warn('Invalid ID3v2 flags field:', flags);
                    return data; // Invalid flags, don't strip
                }
                
                if (flags & (1 << 4)) {
                    console.log('ID3v2 tag has footer');
                    id3len += 10; // Add footer size
                }
                
                // Read synchsafe integer size (bytes 6-9)
                let size = (data[6] << 24) | (data[7] << 16) | (data[8] << 8) | data[9];
                
                // Convert from synchsafe format
                size = (size & 0x7F) + 
                       ((size >> 8) & 0x7F) * 128 +
                       ((size >> 16) & 0x7F) * 128 * 128 +
                       ((size >> 24) & 0x7F) * 128 * 128 * 128;
                
                id3len += size;
                
                console.log(`Stripping ${id3len} bytes of ID3v2 data`);
                
                if (id3len >= data.length) {
                    console.warn('ID3v2 size larger than file, not stripping');
                    return data;
                }
                
                return data.slice(id3len);
            }

            /**
             * Parse filename to extract artist and title
             */
            parseFilename(filename) {
                let title = filename;
                let artist = '';
                
                // Remove .mp3 extension
                const mp3Pos = title.toLowerCase().indexOf('.mp3');
                if (mp3Pos !== -1) {
                    title = title.substring(0, mp3Pos);
                }
                
                // Split on " - " to separate artist and title
                const dashPos = title.indexOf(' - ');
                if (dashPos !== -1) {
                    artist = title.substring(0, dashPos).trim();
                    title = title.substring(dashPos + 3).trim();
                }
                
                // Truncate to 31 characters (C++ limit)
                if (title.length > 31) {
                    title = title.substring(0, 31);
                }
                if (artist.length > 31) {
                    artist = artist.substring(0, 31);
                }
                
                return { artist, title };
            }

            /**
             * Parse TOC data into track list
             */
            parseTOC(tocData) {
                const tracks = [];
                
                // Read track count from offset 4 (little endian)
                const trackCountView = new DataView(tocData.buffer, 4, 4);
                const trackCount = trackCountView.getUint32(0, true);
                
                if (trackCount === 0) {
                    return tracks;
                }
                
                // Parse track entries starting at offset 512
                let curPos = 512;
                
                for (let i = 0; i < trackCount && curPos + 128 <= tocData.length; i++) {
                    const trackOffset = new DataView(tocData.buffer, curPos, 4).getUint32(0, true);
                    const trackSize = new DataView(tocData.buffer, curPos + 4, 4).getUint32(0, true);
                    
                    // Read strings (32 bytes each, null-terminated)
                    const titleBytes = tocData.slice(curPos + 8, curPos + 40);
                    const artistBytes = tocData.slice(curPos + 40, curPos + 72);
                    const albumBytes = tocData.slice(curPos + 72, curPos + 104);
                    
                    const title = String.fromCharCode(...titleBytes).replace(/\0.*$/, '');
                    const artist = String.fromCharCode(...artistBytes).replace(/\0.*$/, '');
                    const album = String.fromCharCode(...albumBytes).replace(/\0.*$/, '');
                    
                    tracks.push({
                        index: i,
                        offset: trackOffset,
                        size: trackSize,
                        title: title,
                        artist: artist,
                        album: album
                    });
                    
                    curPos += 128; // Each track entry is 128 bytes
                }
                
                return tracks;
            }
        }

        // Global file manager instance (will be initialized when connected)
        let fileManager = null;

        /**
         * Protocol Compatibility Test Suite
         * 
         * This comprehensive test suite validates that the JavaScript WebUSB implementation
         * maintains protocol compatibility with the original C++ version.
         * 
         * Tests cover:
         * - USB message sequences and timing
         * - MMC read/write operations with 512-byte alignment
         * - TOC format compatibility and data integrity
         * - File upload/download cycles
         * - Space management algorithms
         * - Edge cases and error handling
         */

        /**
         * Test Results Storage
         */
        let testResults = {
            passed: 0,
            failed: 0,
            tests: []
        };

        /**
         * Test assertion helper
         */
        function assert(condition, message, testName) {
            const result = {
                test: testName,
                message: message,
                passed: condition,
                timestamp: new Date().toISOString()
            };
            
            testResults.tests.push(result);
            
            if (condition) {
                testResults.passed++;
                console.log(`✓ ${testName}: ${message}`);
            } else {
                testResults.failed++;
                console.error(`✗ ${testName}: ${message}`);
            }
            
            return condition;
        }

        /**
         * Test 1: USB Protocol Message Sequences
         * Validates that vendor messages match the original C++ implementation
         */
        async function testUSBProtocolSequences() {
            console.log('=== Testing USB Protocol Message Sequences ===');
            
            if (!connected || !casioUSB) {
                assert(false, 'Device not connected', 'USB Protocol');
                return;
            }

            try {
                // Test 1.1: Device status message (matches C++ usb_vendor_message_in(device_handle, 1, 4, 0, status, 4))
                console.log('Testing device status message...');
                const statusData = await casioUSB.vendorMessageIn(1, 4, 0, 4);
                const status = casioUSB.dataViewToUint8Array(statusData);
                
                assert(status.length === 4, 'Status message returns 4 bytes', 'USB Protocol - Status Length');
                assert(status[0] === 3 && status[1] === 3, 'Device in settled state [3,3,x,x]', 'USB Protocol - Status Values');
                
                // Test 1.2: MMC ID message (matches C++ usb_vendor_message_in(device_handle, 1, 9, 0, MMC_ID, 16))
                console.log('Testing MMC ID message...');
                const mmcIdData = await casioUSB.vendorMessageIn(1, 9, 0, 16);
                const mmcId = casioUSB.dataViewToUint8Array(mmcIdData);
                
                assert(mmcId.length === 16, 'MMC ID message returns 16 bytes', 'USB Protocol - MMC ID Length');
                
                const sizeString = String.fromCharCode(mmcId[3], mmcId[4], mmcId[5]);
                assert(sizeString === "32M", 'MMC ID contains "32M" size identifier', 'USB Protocol - MMC Size');
                
                // Test 1.3: Bulk read setup message format
                console.log('Testing bulk read setup message format...');
                const testOffset = 16896; // Start of data area
                const testLength = 512;
                const transferLength = testLength; // Already aligned
                
                const getSetup = new Uint8Array(16);
                getSetup.fill(0);
                
                // Copy offset to bytes 4-7 (little endian) - matches C++ memcpy(get_setup + 4, &Offset, 4)
                const offsetView = new DataView(getSetup.buffer, 4, 4);
                offsetView.setUint32(0, testOffset, true);
                
                // Copy end offset to bytes 8-11 - matches C++ Offset += TransferLength; memcpy(get_setup + 8, &Offset, 4)
                const endOffset = testOffset + transferLength;
                const endOffsetView = new DataView(getSetup.buffer, 8, 4);
                endOffsetView.setUint32(0, endOffset, true);
                
                // Copy transfer length to bytes 12-15 - matches C++ memcpy(get_setup + 12, &TransferLength, 4)
                const lengthView = new DataView(getSetup.buffer, 12, 4);
                lengthView.setUint32(0, transferLength, true);
                
                // Verify setup buffer format matches C++ implementation
                const offsetCheck = offsetView.getUint32(0, true);
                const endOffsetCheck = endOffsetView.getUint32(0, true);
                const lengthCheck = lengthView.getUint32(0, true);
                
                assert(offsetCheck === testOffset, 'Setup buffer offset field correct', 'USB Protocol - Setup Offset');
                assert(endOffsetCheck === testOffset + transferLength, 'Setup buffer end offset field correct', 'USB Protocol - Setup End Offset');
                assert(lengthCheck === transferLength, 'Setup buffer length field correct', 'USB Protocol - Setup Length');
                
                console.log('USB Protocol message sequences validated');
                
            } catch (error) {
                assert(false, `USB protocol test failed: ${error.message}`, 'USB Protocol - Exception');
            }
        }

        /**
         * Test 2: MMC Read/Write Operations with 512-byte Alignment
         * Validates that MMC operations match the original C++ implementation
         */
        async function testMMCOperations() {
            console.log('=== Testing MMC Read/Write Operations ===');
            
            if (!connected || !mmcManager) {
                assert(false, 'MMC Manager not initialized', 'MMC Operations');
                return;
            }

            try {
                // Test 2.1: 512-byte alignment calculation (matches C++ logic in MMC_Read)
                console.log('Testing 512-byte alignment calculation...');
                
                const testCases = [
                    { input: 100, expected: 512 },    // 100 & 511 = 100, so 100 + (512-100) = 512
                    { input: 512, expected: 512 },    // 512 & 511 = 0, so no padding needed
                    { input: 1000, expected: 1024 },  // 1000 & 511 = 488, so 1000 + (512-488) = 1024
                    { input: 1024, expected: 1024 },  // 1024 & 511 = 0, so no padding needed
                ];
                
                for (const testCase of testCases) {
                    const tempNum = testCase.input & 511;
                    const transferLength = tempNum !== 0 ? testCase.input + (512 - tempNum) : testCase.input;
                    assert(transferLength === testCase.expected, 
                        `Alignment for ${testCase.input} bytes = ${transferLength} (expected ${testCase.expected})`, 
                        'MMC Operations - Alignment');
                }
                
                // Test 2.2: TOC read operation (matches C++ TOC_ReadFromWatch)
                console.log('Testing TOC read operation...');
                const tocData = await mmcManager.readTOC();
                
                assert(tocData.length === 16896, 'TOC read returns exactly 16896 bytes', 'MMC Operations - TOC Size');
                assert(tocData instanceof Uint8Array, 'TOC data is Uint8Array', 'MMC Operations - TOC Type');
                
                // Test 2.3: Small data read with alignment
                console.log('Testing small data read with alignment...');
                const smallData = await mmcManager.read(16896, 100); // Read 100 bytes, should align to 512
                assert(smallData.length === 100, 'Small read returns requested length (not aligned length)', 'MMC Operations - Small Read');
                
                // Test 2.4: Large data read
                console.log('Testing large data read...');
                const largeData = await mmcManager.read(16896, 2048); // Read 2KB (already aligned)
                assert(largeData.length === 2048, 'Large read returns requested length', 'MMC Operations - Large Read');
                
                console.log('MMC read/write operations validated');
                
            } catch (error) {
                assert(false, `MMC operations test failed: ${error.message}`, 'MMC Operations - Exception');
            }
        }

        /**
         * Test 3: TOC Format Compatibility and Data Integrity
         * Validates that TOC parsing matches the original C++ implementation
         */
        async function testTOCCompatibility() {
            console.log('=== Testing TOC Format Compatibility ===');
            
            if (!connected || !mmcManager || !fileManager) {
                assert(false, 'Managers not initialized', 'TOC Compatibility');
                return;
            }

            try {
                // Test 3.1: TOC header format (matches C++ TOC_ParseIntoArray)
                console.log('Testing TOC header format...');
                const tocData = await mmcManager.readTOC();
                
                // Read track count from offset 4 (matches C++ memcpy(&MMC_TrackCount, MMC_TOC + 4, 4))
                const trackCountView = new DataView(tocData.buffer, 4, 4);
                const trackCount = trackCountView.getUint32(0, true); // little endian
                
                assert(trackCount >= 0 && trackCount <= 64, 'Track count in valid range (0-64)', 'TOC Compatibility - Track Count Range');
                
                // Test 3.2: Track entry format (matches C++ track parsing at cur_pos = 512)
                console.log('Testing track entry format...');
                if (trackCount > 0) {
                    const firstTrackOffset = 512; // Matches C++ cur_pos = 512
                    
                    // Read first track entry (128 bytes each, matches C++ cur_pos += 128)
                    const trackOffset = new DataView(tocData.buffer, firstTrackOffset, 4).getUint32(0, true);
                    const trackSize = new DataView(tocData.buffer, firstTrackOffset + 4, 4).getUint32(0, true);
                    
                    // Read title (32 bytes at offset 8, matches C++ memcpy(buffer, MMC_TOC + cur_pos + 8, 32))
                    const titleBytes = tocData.slice(firstTrackOffset + 8, firstTrackOffset + 40);
                    const title = String.fromCharCode(...titleBytes).replace(/\0.*$/, ''); // Remove null termination
                    
                    // Read artist (32 bytes at offset 40, matches C++ memcpy(buffer, MMC_TOC + cur_pos + 40, 32))
                    const artistBytes = tocData.slice(firstTrackOffset + 40, firstTrackOffset + 72);
                    const artist = String.fromCharCode(...artistBytes).replace(/\0.*$/, '');
                    
                    // Read album (32 bytes at offset 72, matches C++ memcpy(buffer, MMC_TOC + cur_pos + 72, 32))
                    const albumBytes = tocData.slice(firstTrackOffset + 72, firstTrackOffset + 104);
                    const album = String.fromCharCode(...albumBytes).replace(/\0.*$/, '');
                    
                    assert(trackOffset >= 16896, 'Track offset after TOC area', 'TOC Compatibility - Track Offset');
                    assert(trackSize > 0, 'Track size is positive', 'TOC Compatibility - Track Size');
                    assert(title.length <= 32, 'Title fits in 32 bytes', 'TOC Compatibility - Title Length');
                    assert(artist.length <= 32, 'Artist fits in 32 bytes', 'TOC Compatibility - Artist Length');
                    assert(album.length <= 32, 'Album fits in 32 bytes', 'TOC Compatibility - Album Length');
                    
                    console.log(`First track: "${title}" by "${artist}" (${trackSize} bytes at offset ${trackOffset})`);
                }
                
                // Test 3.3: TOC generation and round-trip compatibility
                console.log('Testing TOC generation compatibility...');
                const parsedTracks = await fileManager.listFiles();
                
                // Verify parsed tracks match TOC data
                assert(parsedTracks.length === trackCount, 'Parsed track count matches TOC header', 'TOC Compatibility - Parse Count');
                
                if (parsedTracks.length > 0) {
                    const firstTrack = parsedTracks[0];
                    assert(typeof firstTrack.offset === 'number', 'Track offset is number', 'TOC Compatibility - Offset Type');
                    assert(typeof firstTrack.size === 'number', 'Track size is number', 'TOC Compatibility - Size Type');
                    assert(typeof firstTrack.title === 'string', 'Track title is string', 'TOC Compatibility - Title Type');
                    assert(typeof firstTrack.artist === 'string', 'Track artist is string', 'TOC Compatibility - Artist Type');
                    assert(typeof firstTrack.album === 'string', 'Track album is string', 'TOC Compatibility - Album Type');
                }
                
                console.log('TOC format compatibility validated');
                
            } catch (error) {
                assert(false, `TOC compatibility test failed: ${error.message}`, 'TOC Compatibility - Exception');
            }
        }

        /**
         * Test 4: Space Management Algorithm Compatibility
         * Validates that space allocation matches the original C++ implementation
         */
        async function testSpaceManagementCompatibility() {
            console.log('=== Testing Space Management Compatibility ===');
            
            if (!connected || !spaceManager) {
                assert(false, 'Space Manager not initialized', 'Space Management');
                return;
            }

            try {
                // Test 4.1: Space calculation algorithm (matches C++ TOC_CalcFreeSpace)
                console.log('Testing space calculation algorithm...');
                
                // Get current space info
                spaceManager.calcFreeSpace();
                const spaceInfo = spaceManager.getSpaceInfo();
                
                assert(spaceInfo.totalSize === TOTAL_MMC_SIZE, 'Total size matches constant', 'Space Management - Total Size');
                assert(spaceInfo.usedSize >= 0, 'Used size is non-negative', 'Space Management - Used Size');
                assert(spaceInfo.freeSize >= 0, 'Free size is non-negative', 'Space Management - Free Size');
                assert(spaceInfo.usedSize + spaceInfo.freeSize <= spaceInfo.totalSize, 'Used + Free <= Total', 'Space Management - Size Logic');
                
                // Test 4.2: Best-fit allocation algorithm (matches C++ TOC_FindSpace)
                console.log('Testing best-fit allocation algorithm...');
                
                const testSizes = [1024, 5120, 10240, 50000]; // Various sizes to test
                
                for (const size of testSizes) {
                    const foundOffset = spaceManager.findSpace(size);
                    
                    if (foundOffset !== -1) {
                        assert(foundOffset >= 16896, 'Allocated space after TOC', 'Space Management - Allocation Offset');
                        
                        // Verify space is actually available
                        let spaceAvailable = true;
                        for (const [usedOffset, usedSize] of spaceManager.usedSpace) {
                            if (foundOffset < usedOffset + usedSize && foundOffset + size > usedOffset) {
                                spaceAvailable = false;
                                break;
                            }
                        }
                        assert(spaceAvailable, `Allocated space at ${foundOffset} is actually free`, 'Space Management - Allocation Validity');
                    }
                }
                
                // Test 4.3: 512-byte alignment in space usage (matches C++ TOC_UseSpace)
                console.log('Testing 512-byte alignment in space usage...');
                
                const testOffset = 20000;
                const testSize = 1000; // Not aligned
                const expectedAlignedSize = 1024; // 1000 + (512 - (1000 & 511)) = 1000 + 24 = 1024
                
                // Create a temporary space manager to test alignment
                const tempSpaceManager = new SpaceManager();
                tempSpaceManager.useSpace(testOffset, testSize);
                
                const alignedSize = tempSpaceManager.usedSpace.get(testOffset);
                assert(alignedSize === expectedAlignedSize, 
                    `Space usage aligned: ${testSize} -> ${alignedSize} (expected ${expectedAlignedSize})`, 
                    'Space Management - Alignment');
                
                console.log('Space management compatibility validated');
                
            } catch (error) {
                assert(false, `Space management test failed: ${error.message}`, 'Space Management - Exception');
            }
        }

        /**
         * Test 5: File Upload/Download Cycle Validation
         * Tests complete file operations to ensure data integrity
         */
        async function testFileOperationCycles() {
            console.log('=== Testing File Upload/Download Cycles ===');
            
            if (!connected || !fileManager) {
                assert(false, 'File Manager not initialized', 'File Operations');
                return;
            }

            try {
                // Test 5.1: ID3v2 tag detection and stripping (matches C++ get_id3v2_len)
                console.log('Testing ID3v2 tag detection...');
                
                // Create test MP3 data with ID3v2 header
                const id3v2Header = new Uint8Array([
                    0x49, 0x44, 0x33, // "ID3"
                    0x03, 0x00,       // Version 2.3
                    0x00,             // Flags
                    0x00, 0x00, 0x00, 0x0A // Size (10 bytes in synchsafe format)
                ]);
                
                const id3v2TagData = new Uint8Array(10); // 10 bytes of tag data
                const mp3Data = new Uint8Array([0xFF, 0xFB, 0x90, 0x00]); // MP3 frame header
                
                const testFileData = new Uint8Array(id3v2Header.length + id3v2TagData.length + mp3Data.length);
                testFileData.set(id3v2Header, 0);
                testFileData.set(id3v2TagData, id3v2Header.length);
                testFileData.set(mp3Data, id3v2Header.length + id3v2TagData.length);
                
                const strippedData = fileManager.stripID3v2(testFileData);
                const expectedStrippedSize = mp3Data.length; // Should strip ID3v2 header and tag
                
                assert(strippedData.length === expectedStrippedSize, 
                    `ID3v2 stripping: ${testFileData.length} -> ${strippedData.length} (expected ${expectedStrippedSize})`, 
                    'File Operations - ID3v2 Stripping');
                
                // Test 5.2: File metadata parsing
                console.log('Testing file metadata parsing...');
                
                const testFilename = "Artist Name - Song Title.mp3";
                const metadata = fileManager.parseFilename(testFilename);
                
                assert(metadata.artist === "Artist Name", 'Artist parsed correctly', 'File Operations - Artist Parsing');
                assert(metadata.title === "Song Title", 'Title parsed correctly', 'File Operations - Title Parsing');
                
                // Test 5.3: File list consistency
                console.log('Testing file list consistency...');
                
                const fileList = await fileManager.listFiles();
                const spaceInfo = spaceManager.getSpaceInfo();
                
                // Calculate total file sizes
                let totalFileSize = 0;
                for (const file of fileList) {
                    totalFileSize += file.size;
                    
                    // Verify each file has required properties
                    assert(typeof file.offset === 'number', 'File has offset', 'File Operations - File Offset');
                    assert(typeof file.size === 'number', 'File has size', 'File Operations - File Size');
                    assert(typeof file.title === 'string', 'File has title', 'File Operations - File Title');
                    assert(typeof file.artist === 'string', 'File has artist', 'File Operations - File Artist');
                    assert(typeof file.album === 'string', 'File has album', 'File Operations - File Album');
                }
                
                // Verify space accounting matches file sizes
                const expectedUsedSpace = totalFileSize + (16896); // Files + TOC
                const actualUsedSpace = spaceInfo.usedSize;
                
                // Allow for 512-byte alignment differences
                const spaceDifference = Math.abs(expectedUsedSpace - actualUsedSpace);
                const maxAlignmentDifference = fileList.length * 512; // Max alignment padding
                
                assert(spaceDifference <= maxAlignmentDifference, 
                    `Space accounting consistent: expected ~${expectedUsedSpace}, actual ${actualUsedSpace}`, 
                    'File Operations - Space Consistency');
                
                console.log('File operation cycles validated');
                
            } catch (error) {
                assert(false, `File operations test failed: ${error.message}`, 'File Operations - Exception');
            }
        }

        /**
         * Test 6: Edge Cases and Error Handling
         * Tests various edge cases to ensure robust operation
         */
        async function testEdgeCases() {
            console.log('=== Testing Edge Cases and Error Handling ===');
            
            try {
                // Test 6.1: Invalid USB operations
                console.log('Testing invalid USB operations...');
                
                if (connected && casioUSB) {
                    try {
                        // Test invalid vendor message parameters
                        await casioUSB.vendorMessageIn(1, 999, 0, 4); // Invalid request number
                        assert(false, 'Invalid vendor message should throw', 'Edge Cases - Invalid Vendor Message');
                    } catch (error) {
                        assert(true, 'Invalid vendor message throws error', 'Edge Cases - Invalid Vendor Message');
                    }
                }
                
                // Test 6.2: Boundary conditions for space management
                console.log('Testing space management boundary conditions...');
                
                if (spaceManager) {
                    // Test finding space larger than available
                    const hugeSpaceRequest = TOTAL_MMC_SIZE * 2;
                    const foundOffset = spaceManager.findSpace(hugeSpaceRequest);
                    assert(foundOffset === -1, 'Cannot allocate space larger than MMC', 'Edge Cases - Huge Space Request');
                    
                    // Test zero-size space request
                    const zeroSpaceOffset = spaceManager.findSpace(0);
                    assert(zeroSpaceOffset >= 16896 || zeroSpaceOffset === -1, 'Zero-size request handled', 'Edge Cases - Zero Space Request');
                }
                
                // Test 6.3: TOC parsing with edge cases
                console.log('Testing TOC parsing edge cases...');
                
                if (fileManager) {
                    // Test with empty TOC
                    const emptyTOC = new Uint8Array(16896);
                    emptyTOC.fill(0);
                    
                    // Set track count to 0
                    const trackCountView = new DataView(emptyTOC.buffer, 4, 4);
                    trackCountView.setUint32(0, 0, true);
                    
                    const parsedEmptyTracks = fileManager.parseTOC(emptyTOC);
                    assert(parsedEmptyTracks.length === 0, 'Empty TOC parsed correctly', 'Edge Cases - Empty TOC');
                }
                
                // Test 6.4: File name parsing edge cases
                console.log('Testing filename parsing edge cases...');
                
                if (fileManager) {
                    const edgeCaseFilenames = [
                        "NoArtist.mp3",
                        "Artist - .mp3",
                        " - Title.mp3",
                        "Artist-Title.mp3", // No spaces around dash
                        "Very Long Artist Name That Exceeds Limits - Very Long Title Name.mp3"
                    ];
                    
                    for (const filename of edgeCaseFilenames) {
                        const metadata = fileManager.parseFilename(filename);
                        assert(typeof metadata.artist === 'string', `Artist parsed for "${filename}"`, 'Edge Cases - Filename Parsing');
                        assert(typeof metadata.title === 'string', `Title parsed for "${filename}"`, 'Edge Cases - Filename Parsing');
                        assert(metadata.title.length <= 31, `Title truncated for "${filename}"`, 'Edge Cases - Title Truncation');
                        assert(metadata.artist.length <= 31, `Artist truncated for "${filename}"`, 'Edge Cases - Artist Truncation');
                    }
                }
                
                console.log('Edge cases and error handling validated');
                
            } catch (error) {
                assert(false, `Edge cases test failed: ${error.message}`, 'Edge Cases - Exception');
            }
        }

        /**
         * Test 7: USB Protocol Timing and Message Sequences
         * Validates timing requirements and message ordering
         */
        async function testUSBTimingAndSequences() {
            console.log('=== Testing USB Protocol Timing and Sequences ===');
            
            if (!connected || !casioUSB) {
                assert(false, 'USB connection not available', 'USB Timing');
                return;
            }

            try {
                // Test 7.1: Message sequence timing
                console.log('Testing message sequence timing...');
                
                const startTime = performance.now();
                
                // Perform a sequence of operations similar to C++ init_device()
                const status1 = await casioUSB.vendorMessageIn(1, 4, 0, 4);
                const mmcId = await casioUSB.vendorMessageIn(1, 9, 0, 16);
                const status2 = await casioUSB.vendorMessageIn(1, 4, 0, 4);
                
                const endTime = performance.now();
                const totalTime = endTime - startTime;
                
                assert(totalTime < 5000, `Message sequence completed in reasonable time: ${totalTime.toFixed(2)}ms`, 'USB Timing - Sequence Time');
                
                // Test 7.2: Individual message timeouts
                console.log('Testing individual message timeouts...');
                
                const messageStartTime = performance.now();
                const statusData = await casioUSB.vendorMessageIn(1, 4, 0, 4, 1000); // 1 second timeout
                const messageEndTime = performance.now();
                const messageTime = messageEndTime - messageStartTime;
                
                assert(messageTime < 1000, `Individual message completed quickly: ${messageTime.toFixed(2)}ms`, 'USB Timing - Message Time');
                
                // Test 7.3: Bulk operation timing
                console.log('Testing bulk operation timing...');
                
                if (mmcManager) {
                    const bulkStartTime = performance.now();
                    const testData = await mmcManager.read(16896, 1024); // Read 1KB
                    const bulkEndTime = performance.now();
                    const bulkTime = bulkEndTime - bulkStartTime;
                    
                    assert(bulkTime < 2000, `Bulk read completed in reasonable time: ${bulkTime.toFixed(2)}ms`, 'USB Timing - Bulk Time');
                    assert(testData.length === 1024, 'Bulk read returned correct amount of data', 'USB Timing - Bulk Data');
                }
                
                console.log('USB timing and sequences validated');
                
            } catch (error) {
                assert(false, `USB timing test failed: ${error.message}`, 'USB Timing - Exception');
            }
        }

        /**
         * Main Protocol Compatibility Test Runner
         * Runs all test suites and reports results
         */
        async function runProtocolCompatibilityTests() {
            console.log('🧪 Starting Protocol Compatibility Test Suite...');
            console.log('This comprehensive test validates JavaScript WebUSB implementation against the original C++ version.');
            
            // Reset test results
            testResults = {
                passed: 0,
                failed: 0,
                tests: []
            };
            
            const startTime = performance.now();
            
            // Update UI to show testing in progress
            const testButton = document.getElementById('protocolTestBtn');
            const originalText = testButton.textContent;
            testButton.textContent = 'Running Tests...';
            testButton.disabled = true;
            
            try {
                // Run all test suites
                await testUSBProtocolSequences();
                await testMMCOperations();
                await testTOCCompatibility();
                await testSpaceManagementCompatibility();
                await testFileOperationCycles();
                await testEdgeCases();
                await testUSBTimingAndSequences();
                
                const endTime = performance.now();
                const totalTime = (endTime - startTime) / 1000;
                
                // Generate test report
                console.log('\n📊 Protocol Compatibility Test Results:');
                console.log('=' .repeat(50));
                console.log(`✅ Passed: ${testResults.passed}`);
                console.log(`❌ Failed: ${testResults.failed}`);
                console.log(`⏱️  Total Time: ${totalTime.toFixed(2)} seconds`);
                console.log(`📈 Success Rate: ${((testResults.passed / (testResults.passed + testResults.failed)) * 100).toFixed(1)}%`);
                
                // Show detailed results
                if (testResults.failed > 0) {
                    console.log('\n❌ Failed Tests:');
                    testResults.tests.filter(t => !t.passed).forEach(test => {
                        console.log(`   • ${test.test}: ${test.message}`);
                    });
                }
                
                // Display summary in UI
                const message = `Protocol Compatibility Tests Complete!\n` +
                    `Passed: ${testResults.passed}, Failed: ${testResults.failed}\n` +
                    `Success Rate: ${((testResults.passed / (testResults.passed + testResults.failed)) * 100).toFixed(1)}%\n` +
                    `Time: ${totalTime.toFixed(2)}s`;
                
                if (testResults.failed === 0) {
                    showSuccessMessage(message);
                    console.log('🎉 All protocol compatibility tests passed! The JavaScript implementation maintains full compatibility with the original C++ version.');
                } else {
                    showErrorMessage(message);
                    console.log('⚠️  Some protocol compatibility tests failed. Check the console for details.');
                }
                
            } catch (error) {
                console.error('Test suite execution failed:', error);
                showErrorMessage(`Test suite failed: ${error.message}`);
            } finally {
                // Restore UI
                testButton.textContent = originalText;
                testButton.disabled = false;
            }
        }

        /**
         * Generate detailed test report for debugging
         */
        function generateTestReport() {
            const report = {
                timestamp: new Date().toISOString(),
                summary: {
                    passed: testResults.passed,
                    failed: testResults.failed,
                    total: testResults.passed + testResults.failed,
                    successRate: ((testResults.passed / (testResults.passed + testResults.failed)) * 100).toFixed(1)
                },
                tests: testResults.tests,
                environment: {
                    userAgent: navigator.userAgent,
                    webUSBSupported: 'usb' in navigator,
                    connected: connected,
                    deviceInfo: device ? {
                        vendorId: device.vendorId,
                        productId: device.productId,
                        productName: device.productName,
                        manufacturerName: device.manufacturerName
                    } : null
                }
            };
            
            return report;
        }


    </script>
</body>
</html>